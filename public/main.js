/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../GitHub/PRGM/bin/DefaultEnv.js":
/*!*******************************************!*\
  !*** ../../GitHub/PRGM/bin/DefaultEnv.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.evalNewEnv = exports.defaultEnv = void 0;\r\nconst Environment_1 = __webpack_require__(/*! ./eval/Environment */ \"../../GitHub/PRGM/bin/eval/Environment.js\");\r\nconst evaluate_1 = __webpack_require__(/*! ./eval/evaluate */ \"../../GitHub/PRGM/bin/eval/evaluate.js\");\r\nconst parse_1 = __webpack_require__(/*! ./parse */ \"../../GitHub/PRGM/bin/parse.js\");\r\nfunction defaultEnv() {\r\n    let res = new Environment_1.Environment();\r\n    res.def(\"__typeof\", (val) => typeof val);\r\n    res.def(\"__array\", (...args) => new Array(...args));\r\n    res.def(\"__in\", (key, value) => Object.hasOwn(value, key));\r\n    res.def(\"JSON\", JSON);\r\n    res.def(\"Math\", Math);\r\n    res.def(\"now\", () => {\r\n        return performance.now();\r\n    });\r\n    res.def(\"println\", println);\r\n    res.def(\"sleep\", async (delay) => {\r\n        return new Promise((resolve) => setTimeout(resolve, delay));\r\n    });\r\n    return res;\r\n}\r\nexports.defaultEnv = defaultEnv;\r\nasync function println(...data) {\r\n    let res = [];\r\n    for (const v of data) {\r\n        res.push(typeof v == \"object\" && v && v.__isString__ === true ? await v.toString() : v);\r\n    }\r\n    console.log(...res);\r\n}\r\nfunction evalNewEnv(prgm, path = \"/\", pid, beforeExecution, onExit = (code) => { }) {\r\n    let globalEnv = defaultEnv();\r\n    let prog = typeof prgm == \"string\" ? (0, parse_1.parse)(prgm) : prgm;\r\n    if (pid == undefined) {\r\n        globalEnv.def(\"println\", println);\r\n    }\r\n    if (beforeExecution)\r\n        beforeExecution(globalEnv);\r\n    return (0, evaluate_1.evaluate)(prog, globalEnv, pid ?? 0, path, onExit);\r\n}\r\nexports.evalNewEnv = evalNewEnv;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/DefaultEnv.js?");

/***/ }),

/***/ "../../GitHub/PRGM/bin/InputStream.js":
/*!********************************************!*\
  !*** ../../GitHub/PRGM/bin/InputStream.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.InputStream = void 0;\r\nclass InputStream {\r\n    pos = 0;\r\n    line = 1;\r\n    col = 0;\r\n    input;\r\n    onError;\r\n    constructor(input, onError = (err) => { }) {\r\n        this.input = input;\r\n        this.onError = onError;\r\n    }\r\n    next() {\r\n        let ch = this.input.charAt(this.pos++);\r\n        if (ch == \"\\n\")\r\n            this.line++, (this.col = 0);\r\n        else\r\n            this.col++;\r\n        return ch;\r\n    }\r\n    peek() {\r\n        return this.input.charAt(this.pos);\r\n    }\r\n    eof() {\r\n        return this.peek() == \"\";\r\n    }\r\n    croak(msg) {\r\n        let err = new Error(`${msg} (${this.line}:${this.col})\r\n${\"\" ?? 0}`);\r\n        console.error(err);\r\n        this.onError(err);\r\n        return err;\r\n    }\r\n}\r\nexports.InputStream = InputStream;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/InputStream.js?");

/***/ }),

/***/ "../../GitHub/PRGM/bin/TokenStream.js":
/*!********************************************!*\
  !*** ../../GitHub/PRGM/bin/TokenStream.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.TokenStream = exports.TokenTypeChecks = void 0;\r\nvar TokenTypeChecks;\r\n(function (TokenTypeChecks) {\r\n    function check(type, tok) {\r\n        return tok && tok.type == type ? true : false;\r\n    }\r\n    TokenTypeChecks.check = check;\r\n})(TokenTypeChecks = exports.TokenTypeChecks || (exports.TokenTypeChecks = {}));\r\nclass TokenStream {\r\n    current = [];\r\n    keywords = [\r\n        \"if\",\r\n        \"then\",\r\n        \"else\",\r\n        \"do\",\r\n        \"_while\",\r\n        \"while\",\r\n        \"function\",\r\n        \"object\",\r\n        \"class\",\r\n        \"static\",\r\n        \"operator\",\r\n        \"constructor\",\r\n        \"extends\",\r\n        \"import\",\r\n        \"true\",\r\n        \"false\",\r\n        \"null\"\r\n    ];\r\n    input;\r\n    constructor(input) {\r\n        this.input = input;\r\n    }\r\n    is_keyword(x) {\r\n        return this.keywords.includes(x);\r\n    }\r\n    is_digit(ch) {\r\n        return /[0-9]/i.test(ch);\r\n    }\r\n    is_id_start(ch) {\r\n        return /[a-z_]/i.test(ch);\r\n    }\r\n    is_id(ch) {\r\n        return this.is_id_start(ch) || \"?!-+/*%<>=0123456789\".indexOf(ch) >= 0;\r\n    }\r\n    is_op_char(ch) {\r\n        return \".+-*/%=&|<>!\".indexOf(ch) >= 0;\r\n    }\r\n    is_punc(ch) {\r\n        return \",:;(){}[]\".indexOf(ch) >= 0;\r\n    }\r\n    is_whitespace(ch) {\r\n        return \" \\t\\n\\r\".indexOf(ch) >= 0;\r\n    }\r\n    read_while(predicate) {\r\n        var str = \"\";\r\n        while (!this.input.eof() && predicate(this.input.peek()))\r\n            str += this.input.next();\r\n        return str;\r\n    }\r\n    read_number() {\r\n        var has_dot = false;\r\n        var number = this.read_while((ch) => {\r\n            if (ch == \".\") {\r\n                if (has_dot)\r\n                    return false;\r\n                has_dot = true;\r\n                return true;\r\n            }\r\n            return this.is_digit(ch);\r\n        });\r\n        return {\r\n            type: \"num\",\r\n            value: parseFloat(number)\r\n        };\r\n    }\r\n    read_ident() {\r\n        var id = this.read_while(this.is_id.bind(this));\r\n        return {\r\n            type: this.is_keyword(id) ? \"kw\" : \"var\",\r\n            value: id\r\n        };\r\n    }\r\n    escapeChars = {\r\n        n: \"\\n\"\r\n    };\r\n    read_escaped(end) {\r\n        var escaped = false, str = \"\";\r\n        this.input.next();\r\n        while (!this.input.eof()) {\r\n            var ch = this.input.next();\r\n            if (escaped) {\r\n                if (ch in this.escapeChars) {\r\n                    str += this.escapeChars[ch];\r\n                }\r\n                else\r\n                    str += ch;\r\n                escaped = false;\r\n            }\r\n            else if (ch == \"\\\\\") {\r\n                escaped = true;\r\n            }\r\n            else if (ch == end) {\r\n                break;\r\n            }\r\n            else {\r\n                str += ch;\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n    read_string() {\r\n        return { type: \"str\", value: this.read_escaped('\"') };\r\n    }\r\n    read_char() {\r\n        return { type: \"char\", value: this.read_escaped(\"'\") };\r\n    }\r\n    skip_comment() {\r\n        this.read_while((ch) => {\r\n            return ch != \"\\n\";\r\n        });\r\n        this.input.next();\r\n    }\r\n    read_next() {\r\n        this.read_while(this.is_whitespace);\r\n        if (this.input.eof())\r\n            return;\r\n        var ch = this.input.peek();\r\n        if (ch == \"#\") {\r\n            this.skip_comment();\r\n            return this.read_next();\r\n        }\r\n        if (ch == '\"')\r\n            return this.read_string();\r\n        if (ch == \"'\")\r\n            return this.read_char();\r\n        if (this.is_digit(ch))\r\n            return this.read_number();\r\n        if (this.is_id_start(ch))\r\n            return this.read_ident();\r\n        if (this.is_punc(ch))\r\n            return {\r\n                type: \"punc\",\r\n                value: this.input.next()\r\n            };\r\n        if (this.is_op_char(ch))\r\n            return {\r\n                type: \"op\",\r\n                value: this.read_while(this.is_op_char)\r\n            };\r\n        this.input.croak(`Can't handle character: \"${ch}\" (Code: ${ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, \"0\")})`);\r\n        return;\r\n    }\r\n    peek(offset) {\r\n        if (offset) {\r\n            if (this.current.length >= offset)\r\n                return this.current[offset];\r\n            while (offset > 0) {\r\n                this.current.push(this.read_next());\r\n            }\r\n            return this.current[offset];\r\n        }\r\n        return this.current[0] || (this.current.push(this.read_next()), this.current[0]);\r\n    }\r\n    next() {\r\n        var tok = this.current.shift();\r\n        return tok || this.read_next();\r\n    }\r\n    eof() {\r\n        return this.peek() == null;\r\n    }\r\n    croak(msg) {\r\n        return this.input.croak(msg);\r\n    }\r\n}\r\nexports.TokenStream = TokenStream;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/TokenStream.js?");

/***/ }),

/***/ "../../GitHub/PRGM/bin/eval/Environment.js":
/*!*************************************************!*\
  !*** ../../GitHub/PRGM/bin/eval/Environment.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Environment = void 0;\r\nclass Environment {\r\n    vars;\r\n    parent;\r\n    constructor(parent) {\r\n        this.vars = Object.create(parent ? parent.vars : null);\r\n        this.parent = parent;\r\n    }\r\n    extend() {\r\n        return new Environment(this);\r\n    }\r\n    lookup(name) {\r\n        let scope = this;\r\n        while (scope) {\r\n            if (Object.prototype.hasOwnProperty.call(scope.vars, name)) {\r\n                return scope;\r\n            }\r\n            scope = scope.parent;\r\n        }\r\n        return undefined;\r\n    }\r\n    get(name) {\r\n        if (name in this.vars)\r\n            return this.vars[name];\r\n        throw new ReferenceError(`Undefined variable \"${name}\"`);\r\n    }\r\n    getWithNullInsteadOfError(name) {\r\n        if (name in this.vars)\r\n            return this.vars[name];\r\n        return null;\r\n    }\r\n    set(name, value) {\r\n        let scope = this.lookup(name);\r\n        return ((scope || this).vars[name] = value);\r\n    }\r\n    def(name, value) {\r\n        return (this.vars[name] = value);\r\n    }\r\n}\r\nexports.Environment = Environment;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/eval/Environment.js?");

/***/ }),

/***/ "../../GitHub/PRGM/bin/eval/evaluate.js":
/*!**********************************************!*\
  !*** ../../GitHub/PRGM/bin/eval/evaluate.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.evaluate = exports.classOperators = exports.duplicateObj = exports.PRGM_String = void 0;\r\nconst parse_1 = __webpack_require__(/*! ../parse */ \"../../GitHub/PRGM/bin/parse.js\");\r\nconst utils_1 = __webpack_require__(/*! ../utils */ \"../../GitHub/PRGM/bin/utils.js\");\r\n(0, utils_1.useUtils)();\r\nclass PRGM_String {\r\n    async toString() {\r\n        return \"\";\r\n    }\r\n}\r\nexports.PRGM_String = PRGM_String;\r\nfunction duplicateObj(obj) {\r\n    let res = obj;\r\n    if (Array.isArray(obj)) {\r\n        res = obj.toSpliced(0, 0);\r\n    }\r\n    else if (typeof obj == \"object\") {\r\n        res = {};\r\n        for (const key in obj) {\r\n            const element = obj[key];\r\n            res[key] = duplicateObj(element);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexports.duplicateObj = duplicateObj;\r\nexports.classOperators = Symbol(\"ops\");\r\nasync function evaluate(exp, env, pid, _path, onExit = (code) => { }, onError = (err) => { }) {\r\n    function throwGood(error) {\r\n        onError(error);\r\n        console.error(error);\r\n        return error;\r\n    }\r\n    async function applyVar(target, var_, env, path) {\r\n        if (typeof var_ == \"string\") {\r\n            return [target, target[var_], var_];\r\n        }\r\n        else if (var_.type == \"binary\" && var_.operator == \".\" && var_.left.type == \"var\") {\r\n            return await applyVar(target[var_.left.value], var_.right, env, path);\r\n        }\r\n        else if (var_.type == \"binary\" && var_.operator == \"[]\") {\r\n            let [, first] = await applyVar(target, var_.left, env, path);\r\n            let selector = await mainExp(var_.right, env, path);\r\n            const res = await applyVar(first, selector, env, path);\r\n            return res;\r\n        }\r\n        else if (var_.type == \"var\" || var_.type == \"str\") {\r\n            return [target, target[var_.value], var_.value];\r\n        }\r\n        throwGood(new TypeError(\"Invalid dot operator\"));\r\n        return [{}, null, \"\"];\r\n    }\r\n    async function evalDot(env, exp, path) {\r\n        if (exp.left.type == \"call\" && exp.right.type == \"call\") {\r\n            let res = await mainExp(exp.left, env, path);\r\n            if (exp.right.func.type == \"var\") {\r\n                return await call(res[exp.right.func.value], exp.right.args, env, path);\r\n            }\r\n            else\r\n                throwGood(new SyntaxError(\"Syntax error\"));\r\n        }\r\n        let [target, res] = await applyVar(await mainExp(exp.left, env, path), exp.right, env, path);\r\n        if (res === undefined)\r\n            res = null;\r\n        if (typeof res == \"function\")\r\n            res = res.bind(target);\r\n        return res;\r\n    }\r\n    async function setEvalDot(env, exp, path, setValue) {\r\n        let [target, res, key] = await applyVar(await mainExp(exp.left, env, path), exp.right, env, path);\r\n        return (target[key] = await mainExp(setValue, env, path));\r\n    }\r\n    function buildPath(file, path) {\r\n        let newPath = file.startsWith(\"/\") ? file : `${path}/${file}`;\r\n        if (!/\\.\\w+$/.test(newPath))\r\n            newPath += \".prgm\";\r\n        return newPath;\r\n    }\r\n    async function _import(exp, env, path = _path) {\r\n        let code = \"\";\r\n        while (path.startsWith(\"//\"))\r\n            path = path.slice(1);\r\n        let builtPath = buildPath(exp.value.value, path);\r\n        if (typeof fetch != \"undefined\") {\r\n            if (builtPath.startsWith(\"/std/\")) {\r\n                code = await (await fetch(__webpack_require__(\"../../GitHub/PRGM/standardLibrary sync recursive ^\\\\.\\\\/.*$\")(\"./\" + builtPath.split(\"/\").splice(2).join(\"/\")))).text();\r\n            }\r\n            else\r\n                code = await (await fetch(builtPath)).text();\r\n        }\r\n        else {\r\n            const os = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))));\r\n            const path = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))));\r\n            const fs = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))));\r\n            let basePath = \"\";\r\n            if (process.platform == \"win32\") {\r\n                basePath = path.join(os.homedir(), \"AppData\\\\Roaming\\\\npm\\\\node_modules\\\\prgm-lang\");\r\n            }\r\n            if (builtPath.startsWith(\"/std/\")) {\r\n                code = fs.readFileSync(path.join(basePath, \"standardLibrary\", builtPath.split(\"/\").splice(2).join(\"/\"))).toString();\r\n            }\r\n            else\r\n                code = fs.readFileSync(builtPath).toString();\r\n        }\r\n        const ast = (0, parse_1.parse)(code);\r\n        let newPath = exp.value.value.split(\"/\").slice(0, -1).join(\"/\");\r\n        if (!newPath.startsWith(\"/\"))\r\n            newPath = \"/\" + newPath;\r\n        await main(ast, env, path + newPath);\r\n    }\r\n    async function collapseDotOp(exp, env, path) {\r\n        if (exp.operator != \".\")\r\n            return undefined;\r\n        if (exp.right.type == \"binary\" && exp.right.operator == \".\") {\r\n            const leftTarget = await mainExp({\r\n                type: \"binary\",\r\n                operator: \".\",\r\n                left: exp.left,\r\n                right: exp.right.left\r\n            }, env, path);\r\n            return leftTarget;\r\n        }\r\n    }\r\n    async function overloadOp(op, a, b) {\r\n        if (typeof a == \"object\" && a != null && a[exports.classOperators] && op in a[exports.classOperators])\r\n            return await a[exports.classOperators][op](b);\r\n        else if (typeof b == \"object\" && b != null && b[exports.classOperators] && op in b[exports.classOperators])\r\n            return await b[exports.classOperators][op](a);\r\n        return undefined;\r\n    }\r\n    async function apply_op(op, a, b, env, path) {\r\n        async function num(_x) {\r\n            let x = await mainExp(_x, env, path);\r\n            if (typeof x != \"number\")\r\n                throwGood(new TypeError(`Expected number but got ${x}`));\r\n            return x;\r\n        }\r\n        async function div(_x) {\r\n            let x = await mainExp(_x, env, path);\r\n            if ((await num(x)) == 0)\r\n                throwGood(new Error(\"Divide by zero\"));\r\n            return x;\r\n        }\r\n        if (op == \"&&\")\r\n            return (await mainExp(a, env, path)) !== false && (await mainExp(b, env, path));\r\n        if (op == \"||\") {\r\n            let _a = await mainExp(a, env, path);\r\n            return _a !== false ? _a : await mainExp(b, env, path);\r\n        }\r\n        const _a = await mainExp(a, env, path);\r\n        const _b = await mainExp(b, env, path);\r\n        const res = await overloadOp(op, _a, _b);\r\n        if (res)\r\n            return res;\r\n        switch (op) {\r\n            case \"+\":\r\n                return (await num(a)) + (await num(b));\r\n            case \"-\":\r\n                return (await num(a)) - (await num(b));\r\n            case \"*\":\r\n                return (await num(a)) * (await num(b));\r\n            case \"/\":\r\n                return (await num(a)) / (await num(b));\r\n            case \"%\":\r\n                return (await num(a)) % (await num(b));\r\n            case \"<\":\r\n                return num(a) < num(b);\r\n            case \">\":\r\n                return num(a) > num(b);\r\n            case \"<=\":\r\n                return num(a) <= num(b);\r\n            case \">=\":\r\n                return num(a) >= num(b);\r\n            case \"==\":\r\n                return (await mainExp(a, env, path)) === (await mainExp(b, env, path));\r\n            case \"!=\":\r\n                return (await mainExp(a, env, path)) !== (await mainExp(b, env, path));\r\n            case \"[]\":\r\n                return evalDot(env, {\r\n                    type: \"binary\",\r\n                    left: a,\r\n                    operator: \".\",\r\n                    right: await mainExp(b, env, path)\r\n                }, path);\r\n        }\r\n        throwGood(new Error(`Can't apply operator ${op}`));\r\n    }\r\n    function isBadArg(arg) {\r\n        if (arg == undefined)\r\n            return true;\r\n        return false;\r\n    }\r\n    async function defineArgument(names, scope, env, i, args, path) {\r\n        scope.def(names[i].name, i < args.length && !isBadArg(args[i])\r\n            ? args[i]\r\n            : names[i].default === null\r\n                ? null\r\n                : await mainExp(names[i].default, env, path));\r\n    }\r\n    function make_function(env, exp, path) {\r\n        async function _function() {\r\n            let names = exp.vars;\r\n            let scope = env.extend();\r\n            for (let i = 0; i < names.length; i++)\r\n                await defineArgument(names, scope, env, i, arguments, path);\r\n            return await main(exp.body, scope, path);\r\n        }\r\n        if (exp.name)\r\n            env.def(exp.name, _function);\r\n        return _function;\r\n    }\r\n    async function make_class(env, exp, path) {\r\n        async function _function() {\r\n            let constructorIndex = parse_1.ClassUtils.constructorIndex(exp);\r\n            let constructor = null;\r\n            if (constructorIndex != -1) {\r\n                let _constructor = exp.body[constructorIndex];\r\n                if (_constructor.type == \"func\")\r\n                    constructor = _constructor;\r\n            }\r\n            let names = constructor ? constructor.vars : [];\r\n            let bodyScope = env.extend();\r\n            let instance = new (0, eval(`(class ${exp.name} {})`))();\r\n            if (exp.extendsName) {\r\n                bodyScope.def(\"super\", async (...args) => {\r\n                    if (exp.extendsName) {\r\n                        instance = Object.assign(instance, await env.get(exp.extendsName)(...args));\r\n                        bodyScope.def(\"this\", instance);\r\n                    }\r\n                });\r\n            }\r\n            bodyScope.def(\"this\", instance);\r\n            for (let i = 0; i < exp.body.length; i++) {\r\n                const element = exp.body[i];\r\n                switch (element.type) {\r\n                    case \"prop\":\r\n                        if (!element.static)\r\n                            await mainExp({\r\n                                type: \"binary\",\r\n                                operator: \"=\",\r\n                                left: {\r\n                                    type: \"binary\",\r\n                                    operator: \".\",\r\n                                    left: {\r\n                                        type: \"var\",\r\n                                        value: \"this\"\r\n                                    },\r\n                                    right: {\r\n                                        type: \"var\",\r\n                                        value: element.name\r\n                                    }\r\n                                },\r\n                                right: element.value\r\n                            }, bodyScope, path);\r\n                        break;\r\n                    case \"func\":\r\n                        if (!element.static)\r\n                            await mainExp({\r\n                                type: \"binary\",\r\n                                operator: \"=\",\r\n                                left: {\r\n                                    type: \"binary\",\r\n                                    operator: \".\",\r\n                                    left: {\r\n                                        type: \"var\",\r\n                                        value: \"this\"\r\n                                    },\r\n                                    right: {\r\n                                        type: \"var\",\r\n                                        value: element.name\r\n                                    }\r\n                                },\r\n                                right: {\r\n                                    type: \"functionExpr\",\r\n                                    body: element.body,\r\n                                    vars: element.vars\r\n                                }\r\n                            }, bodyScope, path);\r\n                        break;\r\n                    case \"operator\":\r\n                        instance[exports.classOperators] = instance[exports.classOperators] || {};\r\n                        instance[exports.classOperators][element.op] = await main(element.value, bodyScope, path);\r\n                        break;\r\n                }\r\n            }\r\n            let constructorScope = bodyScope.extend();\r\n            if (constructor) {\r\n                for (let i = 0; i < names.length; i++) {\r\n                    await defineArgument(names, constructorScope, bodyScope, i, arguments, path);\r\n                }\r\n                await main(constructor.body, constructorScope, path);\r\n            }\r\n            return instance;\r\n        }\r\n        let staticEnv = env.extend();\r\n        staticEnv.def(\"this\", _function);\r\n        for (let i = 0; i < exp.body.length; i++) {\r\n            const element = exp.body[i];\r\n            switch (element.type) {\r\n                case \"prop\":\r\n                    if (element.static)\r\n                        _function[element.name] = await main(element.value, staticEnv);\r\n                    break;\r\n                case \"func\":\r\n                    if (element.static)\r\n                        _function[element.name] = await main({\r\n                            type: \"function\",\r\n                            body: element.body,\r\n                            vars: element.vars\r\n                        }, staticEnv);\r\n                    break;\r\n            }\r\n        }\r\n        if (exp.name != undefined) {\r\n            env.def(exp.name, _function);\r\n        }\r\n        return _function;\r\n    }\r\n    await _import({\r\n        type: \"import\",\r\n        value: {\r\n            type: \"str\",\r\n            value: \"/std/String\"\r\n        }\r\n    }, env, \"/\");\r\n    env.def(\"exit\", (code) => {\r\n        for (const loop of asyncWhileLoops) {\r\n            clearInterval(loop);\r\n        }\r\n        asyncWhileLoops.length = 0;\r\n        onExit(code || 0);\r\n        throw `exited with code ${code || 0}`;\r\n    });\r\n    const asyncWhileLoops = [];\r\n    async function call(func, callArgs, env, path) {\r\n        if (typeof func != \"function\") {\r\n            throwGood(new TypeError(`${JSON.stringify(func)} is not a function`));\r\n            return false;\r\n        }\r\n        let args = [];\r\n        for (const arg of callArgs) {\r\n            args.push(await mainExp(arg, env, path));\r\n        }\r\n        let res = await func.apply(null, args);\r\n        return res;\r\n    }\r\n    async function mainExp(exp, env, path) {\r\n        return await main((0, parse_1.convertToStatement)(exp), env, path);\r\n    }\r\n    async function main(statement, env, path) {\r\n        switch (statement.type) {\r\n            case \"statementExpr\":\r\n                {\r\n                    let exp = statement.expr;\r\n                    switch (exp.type) {\r\n                        case \"unary\":\r\n                            switch (exp.operator) {\r\n                                case \"!\": {\r\n                                    let val = await mainExp(exp.body, env, path);\r\n                                    return val === false || val === null ? true : false;\r\n                                }\r\n                                case \"-\": {\r\n                                    return apply_op(\"-\", { type: \"num\", value: 1 }, exp.body, env, path);\r\n                                }\r\n                            }\r\n                            return undefined;\r\n                        case \"binary\":\r\n                            switch (exp.operator) {\r\n                                case \"=\":\r\n                                    if (exp.left.type != \"var\" && !(exp.left.type == \"binary\" && exp.left.operator == \".\")) {\r\n                                        throwGood(new TypeError(`Cannot assign to ${JSON.stringify(exp.left)}`));\r\n                                        return null;\r\n                                    }\r\n                                    if (exp.left.type == \"var\")\r\n                                        return env.set(exp.left.value, await mainExp(exp.right, env, path));\r\n                                    else {\r\n                                        return setEvalDot(env, exp.left, path, exp.right);\r\n                                    }\r\n                                case \"+=\":\r\n                                case \"-=\":\r\n                                case \"/=\":\r\n                                case \"*=\":\r\n                                    const res = await overloadOp(exp.operator, await mainExp(exp.left, env, path), await mainExp(exp.right, env, path));\r\n                                    if (res !== undefined)\r\n                                        return res;\r\n                                    return await mainExp({\r\n                                        type: \"binary\",\r\n                                        operator: \"=\",\r\n                                        left: exp.left,\r\n                                        right: {\r\n                                            type: \"binary\",\r\n                                            operator: exp.operator[0],\r\n                                            left: exp.left,\r\n                                            right: exp.right\r\n                                        }\r\n                                    }, env, path);\r\n                                case \".\":\r\n                                    return await evalDot(env, exp, path);\r\n                                default:\r\n                                    return await apply_op(exp.operator, exp.left, exp.right, env, path);\r\n                            }\r\n                        case \"call\":\r\n                            let func = await mainExp(exp.func, env, path);\r\n                            return await call(func, exp.args, env, path);\r\n                        case \"object\": {\r\n                            let res = {};\r\n                            let scope = env.extend();\r\n                            scope.def(\"this\", res);\r\n                            for (const key in exp.data) {\r\n                                if (Object.prototype.hasOwnProperty.call(exp.data, key)) {\r\n                                    const element = exp.data[key];\r\n                                    res[key] = await mainExp(element, scope, path);\r\n                                }\r\n                            }\r\n                            return res;\r\n                        }\r\n                        case \"functionExpr\": {\r\n                            return make_function(env, exp, path);\r\n                        }\r\n                        case \"null\":\r\n                            return null;\r\n                        case \"var\":\r\n                            return env.get(exp.value);\r\n                        case \"str\":\r\n                            return env.get(\"String\")(exp.value.split(\"\"));\r\n                        case \"char\":\r\n                            if (exp.value.length > 1)\r\n                                throwGood(new TypeError(\"Char can hold up to 1 character\"));\r\n                        case \"bool\":\r\n                        case \"num\":\r\n                            return exp.value;\r\n                    }\r\n                }\r\n                break;\r\n            case \"prog\": {\r\n                let val = false;\r\n                for (const _exp of statement.prog) {\r\n                    val = await main(_exp, env, path);\r\n                }\r\n                return val;\r\n            }\r\n            case \"if\":\r\n                let cond = await mainExp(statement.cond, env, path);\r\n                if (cond !== false)\r\n                    return await main(statement.then, env, path);\r\n                return statement.else ? await main(statement.else, env, path) : false;\r\n            case \"do\": {\r\n                do {\r\n                    await main(statement.body, env, path);\r\n                } while ((await mainExp(statement.cond, env, path)) !== false);\r\n                return false;\r\n            }\r\n            case \"_while\": {\r\n                let i = 0;\r\n                const interval = setInterval(async () => {\r\n                    const cond = await mainExp(statement.cond, env, path);\r\n                    if (cond === false && statement.else && i == 0) {\r\n                        await main(statement.else, env, path);\r\n                        clearInterval(interval);\r\n                    }\r\n                    else if (cond) {\r\n                        await main(statement.body, env, path);\r\n                        i++;\r\n                    }\r\n                    else {\r\n                        clearInterval(interval);\r\n                    }\r\n                    i++;\r\n                }, 1000 / 60);\r\n                asyncWhileLoops.push(interval);\r\n                break;\r\n            }\r\n            case \"while\": {\r\n                if (statement.else && (await mainExp(statement.cond, env, path)) === false) {\r\n                    await main(statement.else, env, path);\r\n                }\r\n                else\r\n                    while ((await mainExp(statement.cond, env, path)) !== false) {\r\n                        await main(statement.body, env, path);\r\n                    }\r\n                return false;\r\n            }\r\n            case \"function\": {\r\n                return make_function(env, statement, path);\r\n            }\r\n            case \"class\":\r\n                return make_class(env, statement, path);\r\n            case \"import\":\r\n                await _import(statement, env, path);\r\n                return null;\r\n            default:\r\n                throwGood(new Error(`I don't know how to main an expression of type \"${statement.type}\"`), pid);\r\n        }\r\n    }\r\n    return main(exp, env, _path);\r\n}\r\nexports.evaluate = evaluate;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/eval/evaluate.js?");

/***/ }),

/***/ "../../GitHub/PRGM/bin/index.js":
/*!**************************************!*\
  !*** ../../GitHub/PRGM/bin/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.toPRGM_String = void 0;\r\n__exportStar(__webpack_require__(/*! ./DefaultEnv */ \"../../GitHub/PRGM/bin/DefaultEnv.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./InputStream */ \"../../GitHub/PRGM/bin/InputStream.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./TokenStream */ \"../../GitHub/PRGM/bin/TokenStream.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./eval/Environment */ \"../../GitHub/PRGM/bin/eval/Environment.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./eval/evaluate */ \"../../GitHub/PRGM/bin/eval/evaluate.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./parse */ \"../../GitHub/PRGM/bin/parse.js\"), exports);\r\nasync function toPRGM_String(str, env) {\r\n    return await env.get(\"String\")(str.split(\"\"));\r\n}\r\nexports.toPRGM_String = toPRGM_String;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/index.js?");

/***/ }),

/***/ "../../GitHub/PRGM/bin/parse.js":
/*!**************************************!*\
  !*** ../../GitHub/PRGM/bin/parse.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.parse = exports.convertToStatement = exports.ClassUtils = void 0;\r\nconst InputStream_1 = __webpack_require__(/*! ./InputStream */ \"../../GitHub/PRGM/bin/InputStream.js\");\r\nconst TokenStream_1 = __webpack_require__(/*! ./TokenStream */ \"../../GitHub/PRGM/bin/TokenStream.js\");\r\nconst FALSE = { type: \"bool\", value: false };\r\nvar ClassUtils;\r\n(function (ClassUtils) {\r\n    function constructorIndex(obj) {\r\n        for (let i = 0; i < obj.body.length; i++) {\r\n            const element = obj.body[i];\r\n            if (element.type == \"func\" && element.name == \"constructor\")\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n    ClassUtils.constructorIndex = constructorIndex;\r\n})(ClassUtils = exports.ClassUtils || (exports.ClassUtils = {}));\r\nfunction convertToStatement(expr) {\r\n    return { type: \"statementExpr\", expr };\r\n}\r\nexports.convertToStatement = convertToStatement;\r\nfunction array_forEach_rtn(array, cb) {\r\n    for (let i = 0; i < array.length; i++) {\r\n        const element = array[i];\r\n        const res = cb(element, i, array);\r\n        if (res)\r\n            return res;\r\n    }\r\n    return undefined;\r\n}\r\nfunction parse(str, onError = (err) => { }, testingFlag = false) {\r\n    const input = new TokenStream_1.TokenStream(new InputStream_1.InputStream(str, onError));\r\n    if (testingFlag) {\r\n        input.croak = (msg) => { };\r\n    }\r\n    const UNARY_OPS = [\"!\", \"-\"];\r\n    const PRECEDENCE = {\r\n        \"=\": 1,\r\n        \"+=\": 1,\r\n        \"-=\": 1,\r\n        \"/=\": 1,\r\n        \"*=\": 1,\r\n        \"%=\": 1,\r\n        \"||\": 2,\r\n        \"&&\": 3,\r\n        \"<\": 7,\r\n        \">\": 7,\r\n        \"<=\": 7,\r\n        \">=\": 7,\r\n        \"==\": 7,\r\n        \"!=\": 7,\r\n        \"+\": 10,\r\n        \"-\": 10,\r\n        \"*\": 20,\r\n        \"/\": 20,\r\n        \"%\": 20,\r\n        \".\": 21\r\n    };\r\n    let res = parse_topLevel();\r\n    return res;\r\n    function is_punc(ch) {\r\n        var tok = input.peek();\r\n        return tok && TokenStream_1.TokenTypeChecks.check(\"punc\", tok) && (!ch || tok.value == ch) && tok;\r\n    }\r\n    function is_kw(kw) {\r\n        var tok = input.peek();\r\n        return tok && TokenStream_1.TokenTypeChecks.check(\"kw\", tok) && (!kw || tok.value == kw) && tok;\r\n    }\r\n    function is_op(op) {\r\n        var tok = input.peek();\r\n        return tok && TokenStream_1.TokenTypeChecks.check(\"op\", tok) && (!op || tok.value == op) && tok;\r\n    }\r\n    function skip_punc(ch) {\r\n        if (is_punc(ch))\r\n            input.next();\r\n        else\r\n            input.croak(`Expecting punctuation: \"${ch}\"`);\r\n    }\r\n    function skip_kw(kw) {\r\n        if (is_kw(kw))\r\n            input.next();\r\n        else\r\n            input.croak(`Expecting keyword: \"${kw}\"`);\r\n    }\r\n    function skip_op(op) {\r\n        if (is_op(op))\r\n            input.next();\r\n        else\r\n            input.croak(`Expecting operator: \"${op}\"`);\r\n    }\r\n    function unexpected() {\r\n        return input.croak(`Unexpected token: ${JSON.stringify(input.peek())}`);\r\n    }\r\n    function maybe_binary(left, my_prec) {\r\n        var tok = is_op();\r\n        if (tok) {\r\n            var his_prec = PRECEDENCE[tok.value];\r\n            if (his_prec > my_prec) {\r\n                input.next();\r\n                return maybe_binary({\r\n                    type: \"binary\",\r\n                    operator: tok.value,\r\n                    left: left,\r\n                    right: maybe_binary(parse_atom(), his_prec)\r\n                }, my_prec);\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n    function maybe_access(left, my_prec = 0) {\r\n        var tok = is_op(\".\");\r\n        if (tok) {\r\n            var his_prec = PRECEDENCE[tok.value];\r\n            if (his_prec > my_prec) {\r\n                input.next();\r\n                return maybe_access({\r\n                    type: \"binary\",\r\n                    operator: tok.value,\r\n                    left,\r\n                    right: maybe_access(parse_atom_withoutCall(), his_prec)\r\n                }, my_prec);\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n    function delimited(start, stop, separator, parser) {\r\n        var a = [], first = true;\r\n        skip_punc(start);\r\n        while (!input.eof()) {\r\n            if (is_punc(stop))\r\n                break;\r\n            if (first)\r\n                first = false;\r\n            else\r\n                skip_punc(separator);\r\n            if (is_punc(stop))\r\n                break;\r\n            a.push(parser());\r\n        }\r\n        skip_punc(stop);\r\n        return a;\r\n    }\r\n    function parse_call(func) {\r\n        return {\r\n            type: \"call\",\r\n            func,\r\n            args: delimited(\"(\", \")\", \",\", parse_expression)\r\n        };\r\n    }\r\n    function parse_arrayAccess(val) {\r\n        skip_punc(\"[\");\r\n        let getter = parse_expression();\r\n        skip_punc(\"]\");\r\n        return {\r\n            type: \"binary\",\r\n            left: val,\r\n            operator: \"[]\",\r\n            right: getter\r\n        };\r\n    }\r\n    function parse_varname() {\r\n        var name = input.next();\r\n        if (!TokenStream_1.TokenTypeChecks.check(\"var\", name)) {\r\n            input.croak(\"Expecting variable name\");\r\n            return \"\";\r\n        }\r\n        return name.value;\r\n    }\r\n    function parse_if() {\r\n        skip_kw(\"if\");\r\n        var cond = parse_expression();\r\n        if (!is_punc(\"{\"))\r\n            skip_kw(\"then\");\r\n        var then = parse_statement();\r\n        var ret = {\r\n            type: \"if\",\r\n            cond,\r\n            then\r\n        };\r\n        if (is_punc(\";\"))\r\n            input.next();\r\n        if (is_kw(\"else\")) {\r\n            input.next();\r\n            ret.else = parse_statement();\r\n        }\r\n        return ret;\r\n    }\r\n    function parse_do() {\r\n        skip_kw(\"do\");\r\n        const body = parse_statement();\r\n        skip_kw(\"while\");\r\n        const cond = parse_expression();\r\n        skip_punc(\";\");\r\n        return {\r\n            type: \"do\",\r\n            body,\r\n            cond\r\n        };\r\n    }\r\n    function parse_while() {\r\n        skip_kw(\"while\");\r\n        let cond = parse_expression();\r\n        if (!is_punc(\"{\"))\r\n            skip_kw(\"then\");\r\n        let body = parse_statement();\r\n        let ret = {\r\n            type: \"while\",\r\n            cond,\r\n            body\r\n        };\r\n        if (is_kw(\"else\")) {\r\n            input.next();\r\n            ret.else = parse_statement();\r\n        }\r\n        return ret;\r\n    }\r\n    function parse__while() {\r\n        skip_kw(\"_while\");\r\n        let cond = parse_expression();\r\n        if (!is_punc(\"{\"))\r\n            skip_kw(\"then\");\r\n        let body = parse_statement();\r\n        let ret = {\r\n            type: \"_while\",\r\n            cond,\r\n            body\r\n        };\r\n        if (is_kw(\"else\")) {\r\n            input.next();\r\n            ret.else = parse_statement();\r\n        }\r\n        return ret;\r\n    }\r\n    function parse_import() {\r\n        skip_kw(\"import\");\r\n        let value = null;\r\n        let tok = input.next();\r\n        if (tok && TokenStream_1.TokenTypeChecks.check(\"str\", tok)) {\r\n            skip_punc(\";\");\r\n            return {\r\n                type: \"import\",\r\n                value: tok\r\n            };\r\n        }\r\n        else\r\n            input.croak(`Expecting string, but got \"${tok?.type}\"`);\r\n        return { type: \"import\", value: { type: \"str\", value: \"\" } };\r\n    }\r\n    function parse_argument() {\r\n        let rtn = {\r\n            name: parse_varname(),\r\n            default: null\r\n        };\r\n        if (is_op(\"=\")) {\r\n            input.next();\r\n            rtn.default = parse_expression();\r\n        }\r\n        return rtn;\r\n    }\r\n    function parse_arguments() {\r\n        return delimited(\"(\", \")\", \",\", parse_argument);\r\n    }\r\n    function parse_function() {\r\n        skip_kw(\"function\");\r\n        let name = parse_varname();\r\n        if (!name) {\r\n            return convertToStatement(parse_functionExpr());\r\n        }\r\n        let ret = {\r\n            type: \"function\",\r\n            vars: parse_arguments(),\r\n            name,\r\n            body: parse_statement()\r\n        };\r\n        if (name)\r\n            ret.name = name;\r\n        return ret;\r\n    }\r\n    function parse_functionExpr() {\r\n        skip_kw(\"function\");\r\n        let ret = {\r\n            type: \"functionExpr\",\r\n            vars: parse_arguments(),\r\n            body: parse_statement(false)\r\n        };\r\n        return ret;\r\n    }\r\n    function parse_object() {\r\n        skip_kw(\"object\");\r\n        function parseName() {\r\n            let tok = input.peek();\r\n            if (tok && TokenStream_1.TokenTypeChecks.check(\"str\", tok))\r\n                return tok.value;\r\n            else\r\n                return parse_varname();\r\n        }\r\n        const properties = delimited(\"{\", \"}\", \",\", () => {\r\n            let name = parseName();\r\n            skip_punc(\":\");\r\n            let data = parse_expression();\r\n            return {\r\n                name,\r\n                data\r\n            };\r\n        });\r\n        let data = {};\r\n        for (const { name, data: _data } of properties) {\r\n            data[name] = _data;\r\n        }\r\n        return {\r\n            type: \"object\",\r\n            data\r\n        };\r\n    }\r\n    function parse_class() {\r\n        skip_kw(\"class\");\r\n        let res = {\r\n            type: \"class\",\r\n            body: [],\r\n            name: parse_varname(),\r\n            extendsName: is_kw(\"extends\") ? (skip_kw(\"extends\"), parse_varname()) : null\r\n        };\r\n        skip_punc(\"{\");\r\n        while (!input.eof()) {\r\n            if (is_punc(\"}\"))\r\n                break;\r\n            if (is_kw(\"operator\")) {\r\n                input.next();\r\n                let op = \"\";\r\n                if (is_op()) {\r\n                    op = input.next().value.toString();\r\n                }\r\n                else if (is_punc(\"[\")) {\r\n                    input.next();\r\n                    skip_punc(\"]\");\r\n                    op = \"[]\";\r\n                }\r\n                else {\r\n                    op = parse_varname();\r\n                }\r\n                let vars = parse_arguments();\r\n                let body = parse_prog();\r\n                if (!body) {\r\n                    body = convertToStatement(parse_expression());\r\n                }\r\n                res.body.push({\r\n                    type: \"operator\",\r\n                    op,\r\n                    value: {\r\n                        type: \"function\",\r\n                        body,\r\n                        vars,\r\n                        name: \"\"\r\n                    }\r\n                });\r\n            }\r\n            else if (is_kw(\"constructor\")) {\r\n                input.next();\r\n                res.body.push({\r\n                    type: \"func\",\r\n                    name: \"constructor\",\r\n                    vars: parse_arguments(),\r\n                    body: (() => {\r\n                        let res = parse_prog();\r\n                        if (!res)\r\n                            res = convertToStatement(parse_expression());\r\n                        return res;\r\n                    })(),\r\n                    static: false\r\n                });\r\n            }\r\n            else {\r\n                let isStatic = false;\r\n                if (is_kw(\"static\")) {\r\n                    input.next();\r\n                    isStatic = true;\r\n                }\r\n                let name = parse_varname();\r\n                let vars = is_punc(\"(\") ? parse_arguments() : null;\r\n                if (vars) {\r\n                    let body = parse_prog();\r\n                    if (!body)\r\n                        body = convertToStatement(parse_expression());\r\n                    res.body.push({\r\n                        type: \"func\",\r\n                        body,\r\n                        name,\r\n                        vars,\r\n                        static: isStatic\r\n                    });\r\n                }\r\n                else {\r\n                    skip_op(\"=\");\r\n                    let value = parse_expression();\r\n                    res.body.push({\r\n                        type: \"prop\",\r\n                        name,\r\n                        value,\r\n                        static: isStatic\r\n                    });\r\n                    skip_punc(\";\");\r\n                }\r\n            }\r\n        }\r\n        skip_punc(\"}\");\r\n        return res;\r\n    }\r\n    function parse_bool() {\r\n        return {\r\n            type: \"bool\",\r\n            value: input.next().value == \"true\"\r\n        };\r\n    }\r\n    function parse_null() {\r\n        skip_kw(\"null\");\r\n        return {\r\n            type: \"null\"\r\n        };\r\n    }\r\n    function maybe_call(expr) {\r\n        const res = expr();\r\n        return is_punc(\"(\") ? parse_call(res) : res;\r\n    }\r\n    function maybe_arrayAccess(expr) {\r\n        let res = expr();\r\n        if (!res)\r\n            res = { type: \"null\" };\r\n        return is_punc(\"[\") ? parse_arrayAccess(res) : res;\r\n    }\r\n    function parse_atom() {\r\n        return maybe_call(() => maybe_arrayAccess(() => parse_atom_withoutCall()));\r\n    }\r\n    function parse_atom_withoutCall() {\r\n        let left = maybe_arrayAccess(() => {\r\n            if (is_punc(\"(\")) {\r\n                input.next();\r\n                var exp = parse_expression();\r\n                skip_punc(\")\");\r\n                return exp;\r\n            }\r\n            let op = array_forEach_rtn(UNARY_OPS, (element) => is_op(element));\r\n            if (op) {\r\n                input.next();\r\n                return {\r\n                    type: \"unary\",\r\n                    operator: op.value,\r\n                    body: parse_atom()\r\n                };\r\n            }\r\n            if (is_kw(\"true\") || is_kw(\"false\"))\r\n                return parse_bool();\r\n            if (is_kw(\"null\"))\r\n                return parse_null();\r\n            if (is_kw(\"object\"))\r\n                return parse_object();\r\n            if (is_kw(\"function\")) {\r\n                return parse_functionExpr();\r\n            }\r\n            var tok = input.next();\r\n            if (tok &&\r\n                (TokenStream_1.TokenTypeChecks.check(\"var\", tok) ||\r\n                    TokenStream_1.TokenTypeChecks.check(\"num\", tok) ||\r\n                    TokenStream_1.TokenTypeChecks.check(\"str\", tok) ||\r\n                    TokenStream_1.TokenTypeChecks.check(\"char\", tok)))\r\n                return tok;\r\n            unexpected();\r\n            return;\r\n        });\r\n        if (!left)\r\n            left = { type: \"null\" };\r\n        return maybe_access(left);\r\n    }\r\n    function parse_topLevel() {\r\n        var prog = [];\r\n        while (!input.eof()) {\r\n            let expr = parse_statement();\r\n            prog.push(expr);\r\n        }\r\n        return { type: \"prog\", prog };\r\n    }\r\n    function parse_prog() {\r\n        if (!is_punc(\"{\"))\r\n            return;\r\n        skip_punc(\"{\");\r\n        var prog = [];\r\n        while (!input.eof() && !is_punc(\"}\")) {\r\n            let statement = parse_statement();\r\n            prog.push(statement);\r\n        }\r\n        skip_punc(\"}\");\r\n        return { type: \"prog\", prog: prog };\r\n    }\r\n    function parse_expression() {\r\n        return maybe_call(() => {\r\n            return maybe_binary(parse_atom(), 0);\r\n        });\r\n    }\r\n    function parse_statement(requireSemiColon = true) {\r\n        let res;\r\n        if (is_punc(\"{\")) {\r\n            let _res = parse_prog();\r\n            if (_res)\r\n                res = _res;\r\n        }\r\n        else if (is_kw(\"if\"))\r\n            res = parse_if();\r\n        else if (is_kw(\"do\"))\r\n            res = parse_do();\r\n        else if (is_kw(\"_while\"))\r\n            res = parse__while();\r\n        else if (is_kw(\"while\"))\r\n            res = parse_while();\r\n        else if (is_kw(\"function\"))\r\n            res = parse_function();\r\n        else if (is_kw(\"class\"))\r\n            res = parse_class();\r\n        else if (is_kw(\"import\"))\r\n            res = parse_import();\r\n        if (typeof res == \"undefined\") {\r\n            let expr = parse_expression();\r\n            if (expr) {\r\n                if (requireSemiColon)\r\n                    skip_punc(\";\");\r\n                res = { type: \"statementExpr\", expr };\r\n            }\r\n        }\r\n        if (res) {\r\n            if (is_punc(\";\")) {\r\n                unexpected();\r\n                input.next();\r\n            }\r\n            return res;\r\n        }\r\n        unexpected();\r\n        return { type: \"statementExpr\", expr: { type: \"null\" } };\r\n    }\r\n}\r\nexports.parse = parse;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/parse.js?");

/***/ }),

/***/ "../../GitHub/PRGM/bin/utils.js":
/*!**************************************!*\
  !*** ../../GitHub/PRGM/bin/utils.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.useUtils = void 0;\r\nArray.prototype.asyncMap = async function asyncMap(cb) {\r\n    let arr = [];\r\n    for (let index = 0; index < this.length; index++) {\r\n        const value = this[index];\r\n        arr.push(await cb(value, index, this));\r\n    }\r\n    return arr;\r\n};\r\nfunction useUtils() { }\r\nexports.useUtils = useUtils;\r\n\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/bin/utils.js?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary sync recursive ^\\.\\/.*$":
/*!********************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/ sync ^\.\/.*$ ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./Array.prgm\": \"../../GitHub/PRGM/standardLibrary/Array.prgm\",\n\t\"./Button.prgm\": \"../../GitHub/PRGM/standardLibrary/Button.prgm\",\n\t\"./Map.prgm\": \"../../GitHub/PRGM/standardLibrary/Map.prgm\",\n\t\"./Point.prgm\": \"../../GitHub/PRGM/standardLibrary/Point.prgm\",\n\t\"./Rect.prgm\": \"../../GitHub/PRGM/standardLibrary/Rect.prgm\",\n\t\"./String.prgm\": \"../../GitHub/PRGM/standardLibrary/String.prgm\",\n\t\"./Vec2.prgm\": \"../../GitHub/PRGM/standardLibrary/Vec2.prgm\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"../../GitHub/PRGM/standardLibrary sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/_sync_^\\.\\/.*$?");

/***/ }),

/***/ "./src/AppUtils.ts":
/*!*************************!*\
  !*** ./src/AppUtils.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAppSourceCode = exports.stopApp = exports.openApplication = exports.addApp = exports.defineApplication = exports.Listeners = void 0;\nconst prgm_lang_1 = __webpack_require__(/*! prgm-lang */ \"../../GitHub/PRGM/bin/index.js\");\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst Storage_1 = __webpack_require__(/*! ./Storage */ \"./src/Storage.ts\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./src/Window.ts\");\nvar Listeners;\n(function (Listeners) {\n    function listen(type, listener, window) {\n        switch (type) {\n            case \"keydown\":\n            case \"keyup\": {\n                let listenerFunction = (e) => {\n                    if (window.hasFocus) {\n                        listener(e);\n                    }\n                };\n                addEventListener(type, listenerFunction);\n                return [type, listenerFunction];\n            }\n            case \"mousedown\":\n            case \"mouseup\":\n            case \"mousemove\":\n            case \"click\": {\n                let listenerFunction = mouseListenerFunction(listener, window);\n                addEventListener(type, listenerFunction);\n                return [type, listenerFunction];\n            }\n            default:\n                throw new TypeError(`Unknown listener type: ${type}`);\n        }\n    }\n    Listeners.listen = listen;\n    function mouseListenerFunction(listener, window) {\n        let listenerFunction = (e) => {\n            let res = { x: e.clientX - _1.canvas.offsetLeft, y: e.clientY - _1.canvas.offsetTop };\n            res.x -= window.x;\n            res.y -= window.y;\n            if (window.hasFocus && res.y >= 0) {\n                listener(res);\n            }\n        };\n        return listenerFunction;\n    }\n})(Listeners || (exports.Listeners = Listeners = {}));\nlet applications = {};\nconst defaultAppOptions = {\n    useConsole: true\n};\nfunction mergeValues(required, partial) {\n    let res = {};\n    if (typeof partial == \"undefined\") {\n        res = required;\n    }\n    else\n        for (const key in required) {\n            const element = partial[key];\n            if (typeof element == \"undefined\" || element == null) {\n                res[key] = required[key];\n            }\n            else {\n                res[key] = element;\n            }\n        }\n    return res;\n}\nfunction defineApplication(name, data, options) {\n    if (/^[a-z\\d/]+$/gi.test(name)) {\n        let newOptions = mergeValues(defaultAppOptions, options);\n        applications[name] = { data, options: newOptions };\n    }\n}\nexports.defineApplication = defineApplication;\nlet processes = [];\nlet windows = [];\nlet listeners = [];\nasync function addApp(name) {\n    const apps = Storage_1.storage.getItem(\"apps\");\n    if (!apps.includes(name)) {\n        apps.push(name);\n    }\n    Storage_1.storage.setItem(\"apps\", apps);\n}\nexports.addApp = addApp;\nasync function openApplication(name) {\n    return new Promise(async (resolve) => {\n        if (name in applications) {\n            const apps = Storage_1.storage.getItem(\"apps\");\n            if (!apps.includes(name)) {\n                apps.push(name);\n            }\n            Storage_1.storage.setItem(\"apps\", apps);\n            let pid = 0;\n            processes.forEach((process) => {\n                if (process.pid > pid)\n                    pid = process.pid;\n            });\n            pid++;\n            resolve(pid);\n            let env = (0, prgm_lang_1.defaultEnv)();\n            processes[pid] = {\n                env,\n                pid\n            };\n            env.def(\"listen\", async (type, listener, window) => {\n                let str = await type.toString();\n                listeners.push({ pid, data: Listeners.listen(str, listener, window) });\n            });\n            env.def(\"Window\", async (title, width, height, x, y) => {\n                let window = new Window_1.Window(await title.toString(), x ?? Window_1.Window.WINDOWPOS_CENTERED_X, y ?? Window_1.Window.WINDOWPOS_CENTERED_Y, width, height, pid);\n                windows.push({ pid, data: window });\n                return window;\n            });\n            env.def(\"storage\", {\n                async getItem(_name) {\n                    let str = await _name.toString();\n                    let res = Storage_1.storage.getItem(`app::${name}::${str}`);\n                    if (res === undefined)\n                        res = null;\n                    return res;\n                },\n                async setItem(_name, value) {\n                    let str = await _name.toString();\n                    let _value;\n                    if (value.__isString__ === true)\n                        _value = await value.toString();\n                    else\n                        _value = value;\n                    Storage_1.storage.setItem(`app::${name}::${str}`, value);\n                    return value;\n                }\n            });\n            async function println(...data) {\n                let res = [];\n                for (const v of data) {\n                    res.push(typeof v == \"object\" && v && v.__isString__ === true ? await v.toString() : v);\n                }\n                console.log(`${name}>`, ...res);\n            }\n            env.def(\"println\", println);\n            env.def(\"console\", {\n                log: println\n            });\n            env.def(\"fetch\", async (_url) => {\n                let url = await _url.toString();\n                return await (0, prgm_lang_1.toPRGM_String)(await (await fetch(url)).text(), env);\n            });\n            let exitCode = (0, prgm_lang_1.evaluate)((0, prgm_lang_1.parse)(applications[name].data), env, pid, name.split(\"/\").slice(0, -1).join(\"/\"), (code) => {\n                _stopApp(pid);\n            });\n            return exitCode;\n        }\n        else {\n            defineApplication(name, await getAppSourceCode(name));\n            await openApplication(name);\n            return;\n            console.error(`Application \"${name}\" not found.`);\n        }\n    });\n}\nexports.openApplication = openApplication;\nasync function stopApp(pid) {\n    if (processes[pid]) {\n        processes[pid].env.get(\"exit\")();\n    }\n    await _stopApp(pid);\n}\nexports.stopApp = stopApp;\nasync function _stopApp(pid) {\n    for (let i = 0; i < windows.length; i++) {\n        const window = windows[i];\n        if (window.pid === pid)\n            window.data.closeAfterStop();\n    }\n    windows = windows.filter((val) => val.pid === pid);\n    for (let i = 0; i < listeners.length; i++) {\n        const element = listeners[i];\n        if (element.pid === pid)\n            removeEventListener(element.data[0], element.data[1]);\n    }\n    listeners = listeners.filter((val) => val.pid === pid);\n}\nasync function getAppSourceCode(name) {\n    return await (await fetch(`${name}.prgm`)).text();\n}\nexports.getAppSourceCode = getAppSourceCode;\n\n\n//# sourceURL=webpack://os2/./src/AppUtils.ts?");

/***/ }),

/***/ "./src/Button.ts":
/*!***********************!*\
  !*** ./src/Button.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Button = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./src/Window.ts\");\nclass Button {\n    static buttons = [];\n    x;\n    y;\n    width;\n    height;\n    listeners = [];\n    constructor(x, y, width, height, draw) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.draw = draw ?? this.draw;\n        Button.buttons.push(this);\n    }\n    destroy() {\n        if (Button.buttons.includes(this))\n            Button.buttons.splice(Button.buttons.indexOf(this), 1);\n    }\n    listen(type, listener) {\n        let _val = {\n            call: listener,\n            type\n        };\n        this.listeners.push(_val);\n    }\n    click() {\n        for (let i = 0; i < this.listeners.length; i++) {\n            const element = this.listeners[i];\n            if (element.type == \"click\") {\n                element.call({ x: _1.mouse.x, y: _1.mouse.y });\n            }\n        }\n    }\n    static clickAll() {\n        Window_1.Window.clickAll();\n        for (let i = 0; i < this.buttons.length; i++) {\n            const button = this.buttons[i];\n            if (_1.mouse.x > button.x &&\n                _1.mouse.x < button.x + button.width &&\n                _1.mouse.y > button.y &&\n                _1.mouse.y < button.y + button.height) {\n                button.click();\n            }\n        }\n    }\n    static unClickAll() {\n        Window_1.Window.unClickAll();\n    }\n    draw() {\n        _1.c.fillStyle = \"black\";\n        _1.c.fillRect(this.x, this.y, this.width, this.height);\n    }\n    static drawAll(buttons) {\n        for (const btn of buttons) {\n            btn.draw();\n        }\n    }\n}\nexports.Button = Button;\n\n\n//# sourceURL=webpack://os2/./src/Button.ts?");

/***/ }),

/***/ "./src/Graphics/Graphics.ts":
/*!**********************************!*\
  !*** ./src/Graphics/Graphics.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Graphics = void 0;\nconst prgm_lang_1 = __webpack_require__(/*! prgm-lang */ \"../../GitHub/PRGM/bin/index.js\");\nclass Graphics {\n    target;\n    constructor(target) {\n        this.target = target;\n    }\n    async fillRect(x, y, w, h) {\n        this.target.c_drawBuffer.fillStyle = await this.fillStyle.toString();\n        this.target.c_drawBuffer.fillRect(x, y, w, h);\n    }\n    async fillText(text, x, y) {\n        let str = await text.toString();\n        this.target.c_drawBuffer.fillStyle = await this.fillStyle.toString();\n        this.target.c_drawBuffer.font = await this.font.toString();\n        this.target.c_drawBuffer.fillText(str, x, y);\n    }\n    async textWidth(text) {\n        let str = await text.toString();\n        return this.target.c_drawBuffer.measureText(str).width;\n    }\n    clearRect(x, y, w, h) {\n        this.target.c_drawBuffer.clearRect(x, y, w, h);\n    }\n    clearScreen() {\n        this.fillRect(0, 0, this.target.drawBuffer.width, this.target.drawBuffer.height);\n    }\n    fillStyle = new prgm_lang_1.PRGM_String();\n    font = new prgm_lang_1.PRGM_String();\n}\nexports.Graphics = Graphics;\n\n\n//# sourceURL=webpack://os2/./src/Graphics/Graphics.ts?");

/***/ }),

/***/ "./src/Storage.ts":
/*!************************!*\
  !*** ./src/Storage.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.storage = exports.Storage = exports.expandObjectRef = exports.expandObject = void 0;\nfunction expandObject(obj, key) {\n    if (!key.includes(\"::\"))\n        return obj[key];\n    else {\n        let path = key.split(\"::\");\n        let name = path.shift();\n        return expandObject((obj[name] = obj[name] ?? {}), path.join(\"::\"));\n    }\n}\nexports.expandObject = expandObject;\nfunction expandObjectRef(obj, key) {\n    if (!key.includes(\"::\"))\n        return [obj, key];\n    else {\n        let path = key.split(\"::\");\n        let name = path.shift();\n        return expandObjectRef((obj[name] = obj[name] ?? {}), path.join(\"::\"));\n    }\n}\nexports.expandObjectRef = expandObjectRef;\nclass Storage {\n    storageObj;\n    constructor(storageObj) {\n        this.storageObj = storageObj;\n    }\n    getItem(name) {\n        let path = name.split(\"::\");\n        let lsName = path.shift();\n        if (!this.storageObj.getItem(lsName))\n            return null;\n        let data = JSON.parse(this.storageObj.getItem(lsName) || \"{}\");\n        if (path.length > 0)\n            return expandObject(data, path.join(\"::\"));\n        else\n            return data;\n    }\n    setItem(name, value) {\n        let path = name.split(\"::\");\n        let lsName = path.shift();\n        let data = JSON.parse(this.storageObj.getItem(lsName) || \"{}\");\n        if (path.length > 0) {\n            let [obj, key] = expandObjectRef(data, path.join(\"::\"));\n            obj[key] = value;\n            this.storageObj.setItem(lsName, JSON.stringify(data));\n            return obj[key];\n        }\n        else {\n            this.storageObj.setItem(lsName, JSON.stringify(value));\n        }\n    }\n}\nexports.Storage = Storage;\nexports.storage = new Storage(localStorage);\n\n\n//# sourceURL=webpack://os2/./src/Storage.ts?");

/***/ }),

/***/ "./src/Window.ts":
/*!***********************!*\
  !*** ./src/Window.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Window = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst AppUtils_1 = __webpack_require__(/*! ./AppUtils */ \"./src/AppUtils.ts\");\nconst Button_1 = __webpack_require__(/*! ./Button */ \"./src/Button.ts\");\nconst Graphics_1 = __webpack_require__(/*! ./Graphics/Graphics */ \"./src/Graphics/Graphics.ts\");\nconst taskbar_1 = __webpack_require__(/*! ./taskbar */ \"./src/taskbar.ts\");\nconst defaultWindowOptions = {};\nclass Window {\n    title;\n    x;\n    y;\n    width;\n    height;\n    oldX;\n    oldY;\n    oldW;\n    oldH;\n    hasFocus = false;\n    pid;\n    xBtn;\n    isOpen = true;\n    options;\n    drawBuffer;\n    c_drawBuffer;\n    constructor(title, x, y, width, height, pid, options) {\n        this.options = Object.assign({}, defaultWindowOptions, options);\n        this.pid = pid;\n        this.drawBuffer = document.createElement(\"canvas\");\n        this.c_drawBuffer = this.drawBuffer.getContext(\"2d\");\n        this.drawBuffer.width = width;\n        this.drawBuffer.height = height;\n        y += Window.titleHeight;\n        this.title = title;\n        this.x = x == Window.WINDOWPOS_CENTERED_X ? x - width / 2 : x;\n        this.y = y == Window.WINDOWPOS_CENTERED_Y + Window.titleHeight ? y - height / 2 - taskbar_1.Taskbar.height : y;\n        for (let i = 0; i < Window.windows.length; i++) {\n            const element = Window.windows[i];\n            if (x == element.x && y == element.y) {\n                x += 100;\n                y += 100;\n                break;\n            }\n        }\n        this.width = width;\n        this.height = height;\n        this.oldX = this.x;\n        this.oldY = this.y;\n        this.oldW = this.width;\n        this.oldH = this.height;\n        this.xBtn = new Button_1.Button(this.x + this.width - 25, this.y + 5 - Window.titleHeight, 20, 20, function () {\n            _1.c.drawImage(Window.xBtn, this.x, this.y, this.width, this.height);\n        });\n        this.xBtn.listen(\"click\", this.close.bind(this));\n        Window.windows.push(this);\n    }\n    isLastWindow() {\n        let amount = 0;\n        for (let i = 0; i < Window.windows.length; i++) {\n            const window = Window.windows[i];\n            if (window.pid === this.pid)\n                amount++;\n        }\n        return amount <= 1;\n    }\n    close() {\n        if (this.isOpen) {\n            this.isOpen = false;\n            Window.windows.splice(Window.windows.indexOf(this), 1);\n            this.xBtn.destroy();\n            if (this.isLastWindow())\n                (0, AppUtils_1.stopApp)(this.pid);\n        }\n    }\n    closeAfterStop() {\n        if (this.isOpen) {\n            this.isOpen = false;\n            Window.windows.splice(Window.windows.indexOf(this), 1);\n            this.xBtn.destroy();\n        }\n    }\n    static windows = [];\n    static xBtn;\n    pos1 = 0;\n    pos2 = 0;\n    pos3 = 0;\n    pos4 = 0;\n    static async init() {\n        this.xBtn = await (0, _1.newImage)(\"/x.png\");\n    }\n    static titleHeight = 30;\n    draw() {\n        _1.c.fillStyle = \"white\";\n        _1.c.fillRect(this.x, this.y, this.width, this.height);\n        _1.c.fillStyle = this.hasFocus ? _1.settings.theme.main : _1.settings.theme.lostFocus;\n        _1.c.fillRect(this.x, this.y - Window.titleHeight, this.width, Window.titleHeight);\n        this.xBtn.x = this.x + this.width - 25;\n        this.xBtn.y = this.y + 5 - Window.titleHeight;\n        this.xBtn.draw();\n        _1.c.fillStyle = _1.settings.theme.main == \"black\" ? \"white\" : \"black\";\n        _1.c.font = \"20px Arial\";\n        _1.c.fillText(this.title, this.x + 5, this.y + +_1.c.font.replace(/[^\\d.]/g, \"\") + 2.5 - Window.titleHeight);\n        _1.c.drawImage(this.drawBuffer, this.x, this.y);\n    }\n    titleBarClicked = false;\n    move() {\n        if (this.hasFocus) {\n            if (this.titleBarClicked) {\n                this.pos1 = this.pos3 - _1.mouse.x;\n                this.pos2 = this.pos4 - _1.mouse.y;\n                this.pos3 = _1.mouse.x;\n                this.pos4 = _1.mouse.y;\n                this.y -= this.pos2;\n                this.x -= this.pos1;\n            }\n        }\n    }\n    click() {\n        this.pos3 = _1.mouse.x;\n        this.pos4 = _1.mouse.y;\n        if (_1.mouse.x > this.x && _1.mouse.x < this.x + this.width && _1.mouse.y > this.y + 5 - Window.titleHeight && _1.mouse.y < this.y) {\n            this.titleBarClicked = true;\n            if (this.maximized)\n                this.restore();\n        }\n    }\n    unClick() {\n        this.titleBarClicked = false;\n        if (_1.mouse.y <= 0)\n            this.maximize();\n    }\n    maximized = false;\n    maximize() {\n        this.oldX = this.x;\n        this.oldY = this.y;\n        this.oldW = this.width;\n        this.oldH = this.height;\n        this.x = 0;\n        this.y = 0;\n        this.width = _1.canvas.width;\n        this.height = _1.canvas.height - taskbar_1.Taskbar.height;\n        this.maximized = true;\n    }\n    restore() {\n        this.width = this.oldW;\n        this.height = this.oldH;\n        this.x = _1.mouse.x - this.width / 2;\n        this.maximized = false;\n    }\n    getGraphics() {\n        return new Graphics_1.Graphics(this);\n    }\n    keyListeners = [];\n    keyUpListeners = [];\n    clickListeners = [];\n    rects = [];\n    static drawAll() {\n        this.moveAll();\n        for (let i = this.windows.length - 1; i >= 0; i--) {\n            this.windows[i].draw();\n        }\n    }\n    static noFocusedWindows() {\n        for (const window of this.windows) {\n            if (window.hasFocus)\n                return false;\n        }\n        return true;\n    }\n    static clickAll() {\n        for (let i = 0; i < this.windows.length; i++) {\n            const window = this.windows[i];\n            if (_1.mouse.x > window.x &&\n                _1.mouse.x < window.x + window.width &&\n                _1.mouse.y > window.y - Window.titleHeight &&\n                _1.mouse.y < window.y + window.height &&\n                _1.mouseDown) {\n                if ((this.windows[0] != window && !this.windows[0].hasFocus) || this.windows.length == 1 || this.noFocusedWindows()) {\n                    window.hasFocus = true;\n                    this.windows.splice(this.windows.indexOf(window), 1);\n                    this.windows.unshift(window);\n                }\n                if (this.windows[0] == window && window.hasFocus) {\n                    window.click();\n                }\n            }\n            else {\n                window.hasFocus = false;\n            }\n        }\n    }\n    static unClickAll() {\n        for (let i = 0; i < this.windows.length; i++) {\n            this.windows[i].unClick();\n        }\n    }\n    static moveAll() {\n        for (let i = 0; i < this.windows.length; i++) {\n            this.windows[i].move();\n        }\n    }\n    static WINDOWPOS_CENTERED_X = _1.canvas.width / 2;\n    static WINDOWPOS_CENTERED_Y = _1.canvas.height / 2;\n}\nexports.Window = Window;\n\n\n//# sourceURL=webpack://os2/./src/Window.ts?");

/***/ }),

/***/ "./src/desktop.ts":
/*!************************!*\
  !*** ./src/desktop.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.desktop = exports.Desktop = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nclass Desktop {\n    image;\n    async init() {\n        this.image = await (0, _1.newImage)(\"/wallpaper.jpg\");\n    }\n    draw() {\n        _1.c.drawImage(this.image, 0, 0);\n    }\n}\nexports.Desktop = Desktop;\nexports.desktop = new Desktop();\n\n\n//# sourceURL=webpack://os2/./src/desktop.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.newImage = exports.draw = exports.c = exports.mouseDown = exports.settings = exports.mouse = exports.canvas = void 0;\nexports.canvas = document.querySelector(\"canvas\");\nfunction resize() {\n    exports.canvas.width = innerWidth;\n    exports.canvas.height = innerHeight;\n}\nresize();\nconst Button_1 = __webpack_require__(/*! ./Button */ \"./src/Button.ts\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./src/Window.ts\");\nconst desktop_1 = __webpack_require__(/*! ./desktop */ \"./src/desktop.ts\");\nconst taskbar_1 = __webpack_require__(/*! ./taskbar */ \"./src/taskbar.ts\");\naddEventListener(\"resize\", resize);\nexports.mouse = {\n    x: 0,\n    y: 0\n};\nexports.settings = {\n    theme: {\n        main: \"#7eb5c7\",\n        lostFocus: \"lightblue\"\n    }\n};\nexports.mouseDown = false;\nexports.canvas.addEventListener(\"mousemove\", (e) => {\n    exports.mouse.x = e.clientX;\n    exports.mouse.y = e.clientY;\n});\nexports.canvas.addEventListener(\"mousedown\", () => ((exports.mouseDown = true), Button_1.Button.clickAll()));\nexports.canvas.addEventListener(\"mouseup\", () => ((exports.mouseDown = false), Button_1.Button.unClickAll()));\nexports.c = exports.canvas.getContext(\"2d\");\nasync function draw() {\n    desktop_1.desktop.draw();\n    taskbar_1.taskbar.draw();\n    Window_1.Window.drawAll();\n}\nexports.draw = draw;\nasync function main() {\n    await desktop_1.desktop.init();\n    await taskbar_1.taskbar.init();\n    await Window_1.Window.init();\n    setInterval(draw, 1000 / 60);\n}\nasync function newImage(src) {\n    return new Promise((resolve) => {\n        let image = new Image();\n        image.addEventListener(\"load\", () => resolve(image));\n        image.src = src;\n    });\n}\nexports.newImage = newImage;\nmain();\n\n\n//# sourceURL=webpack://os2/./src/index.ts?");

/***/ }),

/***/ "./src/taskbar.ts":
/*!************************!*\
  !*** ./src/taskbar.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.taskbar = exports.Taskbar = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst AppUtils_1 = __webpack_require__(/*! ./AppUtils */ \"./src/AppUtils.ts\");\nconst Button_1 = __webpack_require__(/*! ./Button */ \"./src/Button.ts\");\nconst Storage_1 = __webpack_require__(/*! ./Storage */ \"./src/Storage.ts\");\nclass Taskbar {\n    static height = 40;\n    icons = [];\n    async init() {\n        Storage_1.storage.setItem(\"apps\", Storage_1.storage.getItem(\"apps\") || []);\n        await (0, AppUtils_1.addApp)(\"/prgm/appStore\");\n        let apps = Storage_1.storage.getItem(\"apps\");\n        for (const name of apps) {\n            await this.makeIcon(name);\n        }\n    }\n    async makeIcon(name) {\n        let iconPath = (await (0, AppUtils_1.getAppSourceCode)(name)).split(\"\\n\")[0];\n        if (!iconPath.startsWith(\"##icon=\"))\n            return;\n        else\n            iconPath = iconPath.slice(7);\n        const icon = await (0, _1.newImage)(iconPath);\n        let btn = new Button_1.Button(this.icons.length * Taskbar.height, _1.canvas.height - Taskbar.height, Taskbar.height, Taskbar.height, function () {\n            _1.c.drawImage(icon, this.x, this.y, this.width, this.height);\n        });\n        btn.listen(\"click\", () => {\n            (0, AppUtils_1.openApplication)(name);\n        });\n        this.icons.push(btn);\n    }\n    draw() {\n        _1.c.fillStyle = _1.settings.theme.main;\n        _1.c.fillRect(0, _1.canvas.height - Taskbar.height, _1.canvas.width, Taskbar.height);\n        Button_1.Button.drawAll(this.icons);\n    }\n}\nexports.Taskbar = Taskbar;\nexports.taskbar = new Taskbar();\n\n\n//# sourceURL=webpack://os2/./src/taskbar.ts?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary/Array.prgm":
/*!****************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/Array.prgm ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"f7aa883b02d3a0ab60b2.prgm\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/Array.prgm?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary/Button.prgm":
/*!*****************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/Button.prgm ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"20c641e21129b6d5968e.prgm\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/Button.prgm?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary/Map.prgm":
/*!**************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/Map.prgm ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"14cc962bb67b726f8ec8.prgm\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/Map.prgm?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary/Point.prgm":
/*!****************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/Point.prgm ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"0413dcafd3dc5464aa42.prgm\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/Point.prgm?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary/Rect.prgm":
/*!***************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/Rect.prgm ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"628b7d09a65deffdc345.prgm\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/Rect.prgm?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary/String.prgm":
/*!*****************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/String.prgm ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"e585edccef9cda9588c3.prgm\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/String.prgm?");

/***/ }),

/***/ "../../GitHub/PRGM/standardLibrary/Vec2.prgm":
/*!***************************************************!*\
  !*** ../../GitHub/PRGM/standardLibrary/Vec2.prgm ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"674578494d77f821be40.prgm\";\n\n//# sourceURL=webpack://os2/../../GitHub/PRGM/standardLibrary/Vec2.prgm?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;