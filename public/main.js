/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/prgm-lang/bin/DefaultEnv.js":
/*!**************************************************!*\
  !*** ./node_modules/prgm-lang/bin/DefaultEnv.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.evalNewEnv = exports.defaultEnv = void 0;\nconst Environment_1 = __webpack_require__(/*! ./eval/Environment */ \"./node_modules/prgm-lang/bin/eval/Environment.js\");\nconst evaluate_1 = __webpack_require__(/*! ./eval/evaluate */ \"./node_modules/prgm-lang/bin/eval/evaluate.js\");\nconst parse_1 = __webpack_require__(/*! ./parse */ \"./node_modules/prgm-lang/bin/parse.js\");\nfunction defaultEnv() {\n    let res = new Environment_1.Environment();\n    res.def(\"__typeof\", (val) => typeof val);\n    res.def(\"__array\", (...args) => new Array(...args));\n    res.def(\"__in\", (key, value) => Object.hasOwn(value, key));\n    res.def(\"JSON\", JSON);\n    res.def(\"Math\", Math);\n    res.def(\"now\", () => {\n        return performance.now();\n    });\n    res.def(\"println\", println);\n    res.def(\"sleep\", async (delay) => {\n        return new Promise((resolve) => setTimeout(resolve, delay));\n    });\n    return res;\n}\nexports.defaultEnv = defaultEnv;\nasync function println(...data) {\n    let res = [];\n    for (const v of data) {\n        res.push(typeof v == \"object\" && v && v.__isString__ === true ? await v.toString() : v);\n    }\n    console.log(...res);\n}\nfunction evalNewEnv(prgm, path = \"/\", pid, beforeExecution, onExit = (code) => { }) {\n    let globalEnv = defaultEnv();\n    let prog = typeof prgm == \"string\" ? (0, parse_1.parse)(prgm) : prgm;\n    if (pid == undefined) {\n        globalEnv.def(\"println\", println);\n    }\n    if (beforeExecution)\n        beforeExecution(globalEnv);\n    return (0, evaluate_1.evaluate)(prog, globalEnv, pid ?? 0, path, onExit);\n}\nexports.evalNewEnv = evalNewEnv;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/DefaultEnv.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/bin/InputStream.js":
/*!***************************************************!*\
  !*** ./node_modules/prgm-lang/bin/InputStream.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InputStream = void 0;\nclass InputStream {\n    pos = 0;\n    line = 1;\n    col = 0;\n    input;\n    onError;\n    constructor(input, onError = (err) => { }) {\n        this.input = input;\n        this.onError = onError;\n    }\n    next() {\n        let ch = this.input.charAt(this.pos++);\n        if (ch == \"\\n\")\n            this.line++, (this.col = 0);\n        else\n            this.col++;\n        return ch;\n    }\n    peek() {\n        return this.input.charAt(this.pos);\n    }\n    eof() {\n        return this.peek() == \"\";\n    }\n    croak(msg) {\n        let err = new Error(`${msg} (${this.line}:${this.col})`);\n        console.error(err);\n        this.onError(err);\n        return err;\n    }\n}\nexports.InputStream = InputStream;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/InputStream.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/bin/TokenStream.js":
/*!***************************************************!*\
  !*** ./node_modules/prgm-lang/bin/TokenStream.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenStream = exports.TokenTypeChecks = void 0;\nvar TokenTypeChecks;\n(function (TokenTypeChecks) {\n    function check(type, tok) {\n        return tok && tok.type == type ? true : false;\n    }\n    TokenTypeChecks.check = check;\n})(TokenTypeChecks || (exports.TokenTypeChecks = TokenTypeChecks = {}));\nclass TokenStream {\n    current = [];\n    keywords = new Set([\n        \"if\",\n        \"then\",\n        \"else\",\n        \"do\",\n        \"_while\",\n        \"while\",\n        \"for\",\n        \"function\",\n        \"object\",\n        \"class\",\n        \"record\",\n        \"static\",\n        \"operator\",\n        \"constructor\",\n        \"extends\",\n        \"import\",\n        \"export\",\n        \"true\",\n        \"false\",\n        \"null\",\n        \"syntax\"\n    ]);\n    registerKeyword(keyword) {\n        this.keywords.add(keyword);\n    }\n    input;\n    constructor(input) {\n        this.input = input;\n    }\n    is_keyword(x) {\n        return this.keywords.has(x);\n    }\n    is_digit(ch) {\n        return /[0-9]/i.test(ch);\n    }\n    is_id_start(ch) {\n        return /[a-z_]/i.test(ch);\n    }\n    is_id(ch) {\n        return this.is_id_start(ch) || \"?!-+/*%<>=0123456789\".indexOf(ch) >= 0;\n    }\n    is_op_char(ch) {\n        return \".+-*/%=&|<>!$\".indexOf(ch) >= 0;\n    }\n    is_punc(ch) {\n        return \",:;(){}[]\".indexOf(ch) >= 0;\n    }\n    is_whitespace(ch) {\n        return \" \\t\\n\\r\".indexOf(ch) >= 0;\n    }\n    read_while(predicate) {\n        var str = \"\";\n        while (!this.input.eof() && predicate(this.input.peek()))\n            str += this.input.next();\n        return str;\n    }\n    read_number() {\n        var has_dot = false;\n        var number = this.read_while((ch) => {\n            if (ch == \".\") {\n                if (has_dot)\n                    return false;\n                has_dot = true;\n                return true;\n            }\n            return this.is_digit(ch);\n        });\n        return {\n            type: \"num\",\n            value: parseFloat(number)\n        };\n    }\n    read_ident() {\n        var id = this.read_while(this.is_id.bind(this));\n        return {\n            type: this.is_keyword(id) ? \"kw\" : \"var\",\n            value: id\n        };\n    }\n    escapeChars = {\n        n: \"\\n\"\n    };\n    read_escaped(end) {\n        var escaped = false, str = \"\";\n        this.input.next();\n        while (!this.input.eof()) {\n            var ch = this.input.next();\n            if (escaped) {\n                if (ch in this.escapeChars) {\n                    str += this.escapeChars[ch];\n                }\n                else\n                    str += ch;\n                escaped = false;\n            }\n            else if (ch == \"\\\\\") {\n                escaped = true;\n            }\n            else if (ch == end) {\n                break;\n            }\n            else {\n                str += ch;\n            }\n        }\n        return str;\n    }\n    read_string() {\n        return { type: \"str\", value: this.read_escaped('\"') };\n    }\n    read_char() {\n        return { type: \"char\", value: this.read_escaped(\"'\") };\n    }\n    skip_comment() {\n        this.read_while((ch) => {\n            return ch != \"\\n\";\n        });\n        this.input.next();\n    }\n    read_next() {\n        this.read_while(this.is_whitespace);\n        if (this.input.eof())\n            return;\n        var ch = this.input.peek();\n        if (ch == \"#\") {\n            this.skip_comment();\n            return this.read_next();\n        }\n        if (ch == '\"')\n            return this.read_string();\n        if (ch == \"'\")\n            return this.read_char();\n        if (this.is_digit(ch))\n            return this.read_number();\n        if (this.is_id_start(ch))\n            return this.read_ident();\n        if (this.is_punc(ch))\n            return {\n                type: \"punc\",\n                value: this.input.next()\n            };\n        if (this.is_op_char(ch))\n            return {\n                type: \"op\",\n                value: this.read_while(this.is_op_char)\n            };\n        this.input.croak(`Can't handle character: \"${ch}\" (Code: ${ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, \"0\")})`);\n        return;\n    }\n    peek(offset) {\n        if (offset) {\n            if (this.current.length >= offset)\n                return this.current[offset];\n            while (offset > 0) {\n                this.current.push(this.read_next());\n            }\n            return this.current[offset];\n        }\n        return this.current[0] || (this.current.push(this.read_next()), this.current[0]);\n    }\n    next() {\n        var tok = this.current.shift();\n        return tok || this.read_next();\n    }\n    eof() {\n        return this.peek() == null;\n    }\n    croak(msg) {\n        return this.input.croak(msg);\n    }\n}\nexports.TokenStream = TokenStream;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/TokenStream.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/bin/eval/Environment.js":
/*!********************************************************!*\
  !*** ./node_modules/prgm-lang/bin/eval/Environment.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Environment = void 0;\nclass Environment {\n    vars;\n    parent;\n    constructor(parent) {\n        this.vars = Object.create(parent ? parent.vars : null);\n        this.parent = parent;\n    }\n    extend() {\n        return new Environment(this);\n    }\n    lookup(name) {\n        let scope = this;\n        while (scope) {\n            if (Object.prototype.hasOwnProperty.call(scope.vars, name)) {\n                return scope;\n            }\n            scope = scope.parent;\n        }\n        return undefined;\n    }\n    get(name) {\n        if (name in this.vars)\n            return this.vars[name];\n        throw new ReferenceError(`Undefined variable \"${name}\"`);\n    }\n    getWithNullInsteadOfError(name) {\n        if (name in this.vars)\n            return this.vars[name];\n        return null;\n    }\n    set(name, value) {\n        let scope = this.lookup(name);\n        return ((scope || this).vars[name] = value);\n    }\n    def(name, value) {\n        return (this.vars[name] = value);\n    }\n}\nexports.Environment = Environment;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/eval/Environment.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/bin/eval/evaluate.js":
/*!*****************************************************!*\
  !*** ./node_modules/prgm-lang/bin/eval/evaluate.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.evaluate = exports.classOperators = exports.duplicateObj = exports.PRGM_String = void 0;\nconst parse_1 = __webpack_require__(/*! ../parse */ \"./node_modules/prgm-lang/bin/parse.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/prgm-lang/bin/utils.js\");\n(0, utils_1.useUtils)();\nclass PRGM_String {\n    async toString() {\n        return \"\";\n    }\n}\nexports.PRGM_String = PRGM_String;\nfunction duplicateObj(obj) {\n    let res = obj;\n    if (Array.isArray(obj)) {\n        res = obj.toSpliced(0, 0);\n    }\n    else if (typeof obj == \"object\") {\n        res = {};\n        for (const key in obj) {\n            const element = obj[key];\n            res[key] = duplicateObj(element);\n        }\n    }\n    return res;\n}\nexports.duplicateObj = duplicateObj;\nexports.classOperators = Symbol(\"ops\");\nasync function evaluate(exp, exportEnv, pid, _path, onExit = (code) => { }, onError = (err) => { }) {\n    const env = exportEnv.extend();\n    function throwGood(error) {\n        onError(error);\n        console.error(error);\n        return error;\n    }\n    async function applyVar(target, var_, env, path) {\n        if (typeof var_ == \"string\") {\n            return [target, target[var_], var_];\n        }\n        else if (var_.type == \"binary\" && var_.operator == \".\" && var_.left.type == \"var\") {\n            return await applyVar(target[var_.left.value], var_.right, env, path);\n        }\n        else if (var_.type == \"binary\" && var_.operator == \"[]\") {\n            let [, first] = await applyVar(target, var_.left, env, path);\n            let selector = await mainExp(var_.right, env, path);\n            const res = await applyVar(first, selector, env, path);\n            return res;\n        }\n        else if (var_.type == \"var\" || var_.type == \"str\") {\n            return [target, target[var_.value], var_.value];\n        }\n        throwGood(new TypeError(\"Invalid dot operator\"));\n        return [{}, null, \"\"];\n    }\n    async function evalDot(env, exp, path) {\n        if (exp.left.type == \"call\" && exp.right.type == \"call\") {\n            let res = await mainExp(exp.left, env, path);\n            if (exp.right.func.type == \"var\") {\n                return await call(res[exp.right.func.value], exp.right.args, env, path);\n            }\n            else\n                throwGood(new SyntaxError(\"Syntax error\"));\n        }\n        let [target, res] = await applyVar(await mainExp(exp.left, env, path), exp.right, env, path);\n        if (res === undefined)\n            res = null;\n        if (typeof res == \"function\")\n            res = res.bind(target);\n        return res;\n    }\n    async function setEvalDot(env, exp, path, setValue) {\n        let [target, res, key] = await applyVar(await mainExp(exp.left, env, path), exp.right, env, path);\n        return (target[key] = await mainExp(setValue, env, path));\n    }\n    function buildPath(file, path) {\n        let newPath = file.startsWith(\"/\") ? file : `${path}/${file}`;\n        if (!/\\.\\w+$/.test(newPath))\n            newPath += \".prgm\";\n        return newPath;\n    }\n    async function _import(exp, env, path = _path) {\n        let code = \"\";\n        while (path.startsWith(\"//\"))\n            path = path.slice(1);\n        let builtPath = buildPath(exp.value.value, path);\n        if (typeof process == \"undefined\") {\n            if (builtPath.startsWith(\"/std/\")) {\n                code = await (await fetch(__webpack_require__(\"./node_modules/prgm-lang/standardLibrary sync recursive ^\\\\.\\\\/.*$\")(\"./\" + builtPath.split(\"/\").splice(2).join(\"/\")))).text();\n            }\n            else\n                code = await (await fetch(builtPath)).text();\n        }\n        else {\n            const os = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))));\n            const path = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))));\n            const fs = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))));\n            let basePath = \"\";\n            if (process.platform == \"win32\") {\n                basePath = path.join(os.homedir(), \"AppData\", \"Roaming\", \"npm\", \"node_modules\", \"prgm-lang\");\n            }\n            else if (process.platform == \"darwin\") {\n                basePath = path.join(\"/usr\", \"local\", \"lib\", \"node_modules\", \"prgm-lang\");\n            }\n            if (builtPath.startsWith(\"/std/\")) {\n                code = fs.readFileSync(path.join(basePath, \"standardLibrary\", builtPath.split(\"/\").splice(2).join(\"/\"))).toString();\n            }\n            else\n                code = fs.readFileSync(builtPath).toString();\n        }\n        const ast = (0, parse_1.parse)(code);\n        let newPath = exp.value.value.split(\"/\").slice(0, -1).join(\"/\");\n        if (!newPath.startsWith(\"/\"))\n            newPath = \"/\" + newPath;\n        await main(ast, env, path + newPath);\n    }\n    async function collapseDotOp(exp, env, path) {\n        if (exp.operator != \".\")\n            return undefined;\n        if (exp.right.type == \"binary\" && exp.right.operator == \".\") {\n            const leftTarget = await mainExp({\n                type: \"binary\",\n                operator: \".\",\n                left: exp.left,\n                right: exp.right.left\n            }, env, path);\n            return leftTarget;\n        }\n    }\n    async function overloadOp(op, a, b) {\n        if (typeof a == \"object\" && a != null && a[exports.classOperators] && op in a[exports.classOperators])\n            return await a[exports.classOperators][op](b);\n        else if (typeof b == \"object\" && b != null && b[exports.classOperators] && op in b[exports.classOperators])\n            return await b[exports.classOperators][op](a);\n        return undefined;\n    }\n    async function apply_op(op, a, b, env, path) {\n        async function num(_x) {\n            let x = await mainExp(_x, env, path);\n            if (typeof x != \"number\")\n                throwGood(new TypeError(`Expected number but got ${x}`));\n            return x;\n        }\n        async function div(_x) {\n            let x = await mainExp(_x, env, path);\n            if ((await num(x)) == 0)\n                throwGood(new Error(\"Divide by zero\"));\n            return x;\n        }\n        if (op == \"&&\")\n            return (await mainExp(a, env, path)) !== false && (await mainExp(b, env, path));\n        if (op == \"||\") {\n            let _a = await mainExp(a, env, path);\n            return _a !== false ? _a : await mainExp(b, env, path);\n        }\n        const _a = await mainExp(a, env, path);\n        const _b = await mainExp(b, env, path);\n        const res = await overloadOp(op, _a, _b);\n        if (res)\n            return res;\n        switch (op) {\n            case \"+\":\n                return (await num(a)) + (await num(b));\n            case \"-\":\n                return (await num(a)) - (await num(b));\n            case \"*\":\n                return (await num(a)) * (await num(b));\n            case \"/\":\n                return (await num(a)) / (await num(b));\n            case \"%\":\n                return (await num(a)) % (await num(b));\n            case \"<\":\n                return num(a) < num(b);\n            case \">\":\n                return num(a) > num(b);\n            case \"<=\":\n                return num(a) <= num(b);\n            case \">=\":\n                return num(a) >= num(b);\n            case \"==\":\n                return (await mainExp(a, env, path)) === (await mainExp(b, env, path));\n            case \"!=\":\n                return (await mainExp(a, env, path)) !== (await mainExp(b, env, path));\n            case \"[]\":\n                return evalDot(env, {\n                    type: \"binary\",\n                    left: a,\n                    operator: \".\",\n                    right: await mainExp(b, env, path)\n                }, path);\n        }\n        throwGood(new Error(`Can't apply operator ${op}`));\n    }\n    function isBadArg(arg) {\n        if (arg == undefined)\n            return true;\n        return false;\n    }\n    async function defineArgument(names, scope, env, i, args, path) {\n        scope.def(names[i].name, i < args.length && !isBadArg(args[i]) ? args[i] : names[i].default === null ? null : await mainExp(names[i].default, env, path));\n    }\n    function make_function(env, exp, path) {\n        async function _function() {\n            let names = exp.vars;\n            let scope = env.extend();\n            for (let i = 0; i < names.length; i++)\n                await defineArgument(names, scope, env, i, arguments, path);\n            return await main(exp.body, scope, path);\n        }\n        if (exp.name)\n            env.def(exp.name, _function);\n        return _function;\n    }\n    async function make_class(env, exp, path) {\n        async function _function() {\n            let constructorIndex = parse_1.ClassUtils.constructorIndex(exp);\n            let constructor = null;\n            if (constructorIndex != -1) {\n                let _constructor = exp.body[constructorIndex];\n                if (_constructor.type == \"func\")\n                    constructor = _constructor;\n            }\n            let names = constructor ? constructor.vars : [];\n            let bodyScope = env.extend();\n            let instance = new (0, eval(`(class ${exp.name} {})`))();\n            if (exp.extendsName) {\n                bodyScope.def(\"super\", async (...args) => {\n                    if (exp.extendsName) {\n                        instance = Object.assign(instance, await env.get(exp.extendsName)(...args));\n                        bodyScope.def(\"this\", instance);\n                    }\n                });\n            }\n            bodyScope.def(\"this\", instance);\n            for (let i = 0; i < exp.body.length; i++) {\n                const element = exp.body[i];\n                switch (element.type) {\n                    case \"prop\":\n                        if (!element.static)\n                            await mainExp({\n                                type: \"binary\",\n                                operator: \"=\",\n                                left: {\n                                    type: \"binary\",\n                                    operator: \".\",\n                                    left: {\n                                        type: \"var\",\n                                        value: \"this\"\n                                    },\n                                    right: {\n                                        type: \"var\",\n                                        value: element.name\n                                    }\n                                },\n                                right: element.value\n                            }, bodyScope, path);\n                        break;\n                    case \"func\":\n                        if (!element.static)\n                            await mainExp({\n                                type: \"binary\",\n                                operator: \"=\",\n                                left: {\n                                    type: \"binary\",\n                                    operator: \".\",\n                                    left: {\n                                        type: \"var\",\n                                        value: \"this\"\n                                    },\n                                    right: {\n                                        type: \"var\",\n                                        value: element.name\n                                    }\n                                },\n                                right: {\n                                    type: \"functionExpr\",\n                                    body: element.body,\n                                    vars: element.vars\n                                }\n                            }, bodyScope, path);\n                        break;\n                    case \"operator\":\n                        instance[exports.classOperators] = instance[exports.classOperators] || {};\n                        instance[exports.classOperators][element.op] = await main(element.value, bodyScope, path);\n                        break;\n                }\n            }\n            let constructorScope = bodyScope.extend();\n            if (constructor) {\n                for (let i = 0; i < names.length; i++) {\n                    await defineArgument(names, constructorScope, bodyScope, i, arguments, path);\n                }\n                await main(constructor.body, constructorScope, path);\n            }\n            return instance;\n        }\n        let staticEnv = env.extend();\n        staticEnv.def(\"this\", _function);\n        for (let i = 0; i < exp.body.length; i++) {\n            const element = exp.body[i];\n            switch (element.type) {\n                case \"prop\":\n                    if (element.static)\n                        _function[element.name] = await main(element.value, staticEnv);\n                    break;\n                case \"func\":\n                    if (element.static)\n                        _function[element.name] = await main({\n                            type: \"function\",\n                            body: element.body,\n                            vars: element.vars\n                        }, staticEnv);\n                    break;\n            }\n        }\n        if (exp.name != undefined) {\n            env.def(exp.name, _function);\n        }\n        return _function;\n    }\n    await _import({\n        type: \"import\",\n        value: {\n            type: \"str\",\n            value: \"/std/String\"\n        }\n    }, env, \"/\");\n    env.def(\"exit\", (code) => {\n        for (const loop of asyncWhileLoops) {\n            clearInterval(loop);\n        }\n        asyncWhileLoops.length = 0;\n        onExit(code || 0);\n        throw `exited with code ${code || 0}`;\n    });\n    const asyncWhileLoops = [];\n    async function call(func, callArgs, env, path) {\n        if (typeof func != \"function\") {\n            throwGood(new TypeError(`${JSON.stringify(func)} is not a function`));\n            return false;\n        }\n        let args = [];\n        for (const arg of callArgs) {\n            args.push(await mainExp(arg, env, path));\n        }\n        let res = await func.apply(null, args);\n        return res;\n    }\n    async function mainExp(exp, env, path) {\n        return await main((0, parse_1.convertToStatement)(exp), env, path);\n    }\n    async function main(statement, env, path) {\n        switch (statement.type) {\n            case \"statementExpr\":\n                {\n                    let exp = statement.expr;\n                    switch (exp.type) {\n                        case \"unary\":\n                            switch (exp.operator) {\n                                case \"!\": {\n                                    let val = await mainExp(exp.body, env, path);\n                                    return val === false || val === null ? true : false;\n                                }\n                                case \"-\": {\n                                    return apply_op(\"-\", { type: \"num\", value: 1 }, exp.body, env, path);\n                                }\n                            }\n                            return undefined;\n                        case \"binary\":\n                            switch (exp.operator) {\n                                case \"=\":\n                                    if (exp.left.type != \"var\" && !(exp.left.type == \"binary\" && exp.left.operator == \".\")) {\n                                        throwGood(new TypeError(`Cannot assign to ${JSON.stringify(exp.left)}`));\n                                        return null;\n                                    }\n                                    if (exp.left.type == \"var\")\n                                        return env.set(exp.left.value, await mainExp(exp.right, env, path));\n                                    else {\n                                        return setEvalDot(env, exp.left, path, exp.right);\n                                    }\n                                case \"+=\":\n                                case \"-=\":\n                                case \"/=\":\n                                case \"*=\":\n                                    const res = await overloadOp(exp.operator, await mainExp(exp.left, env, path), await mainExp(exp.right, env, path));\n                                    if (res !== undefined)\n                                        return res;\n                                    return await mainExp({\n                                        type: \"binary\",\n                                        operator: \"=\",\n                                        left: exp.left,\n                                        right: {\n                                            type: \"binary\",\n                                            operator: exp.operator[0],\n                                            left: exp.left,\n                                            right: exp.right\n                                        }\n                                    }, env, path);\n                                case \".\":\n                                    return await evalDot(env, exp, path);\n                                default:\n                                    return await apply_op(exp.operator, exp.left, exp.right, env, path);\n                            }\n                        case \"call\":\n                            let func = await mainExp(exp.func, env, path);\n                            return await call(func, exp.args, env, path);\n                        case \"object\": {\n                            let res = {};\n                            let scope = env.extend();\n                            scope.def(\"this\", res);\n                            for (const key in exp.data) {\n                                if (Object.prototype.hasOwnProperty.call(exp.data, key)) {\n                                    const element = exp.data[key];\n                                    res[key] = await mainExp(element, scope, path);\n                                }\n                            }\n                            return res;\n                        }\n                        case \"functionExpr\": {\n                            return make_function(env, exp, path);\n                        }\n                        case \"null\":\n                            return null;\n                        case \"var\":\n                            return env.get(exp.value);\n                        case \"str\":\n                            return env.get(\"String\")(exp.value.split(\"\"));\n                        case \"char\":\n                            if (exp.value.length > 1)\n                                throwGood(new TypeError(\"Char can hold up to 1 character\"));\n                        case \"bool\":\n                        case \"num\":\n                            return exp.value;\n                    }\n                }\n                break;\n            case \"prog\": {\n                let val = false;\n                for (const _exp of statement.prog) {\n                    val = await main(_exp, env, path);\n                }\n                return val;\n            }\n            case \"if\":\n                let cond = await mainExp(statement.cond, env, path);\n                if (cond !== false)\n                    return await main(statement.then, env, path);\n                return statement.else ? await main(statement.else, env, path) : false;\n            case \"do\": {\n                do {\n                    await main(statement.body, env, path);\n                } while ((await mainExp(statement.cond, env, path)) !== false);\n                return false;\n            }\n            case \"_while\": {\n                let i = 0;\n                const interval = setInterval(async () => {\n                    const cond = await mainExp(statement.cond, env, path);\n                    if (cond === false && statement.else && i == 0) {\n                        await main(statement.else, env, path);\n                        clearInterval(interval);\n                    }\n                    else if (cond) {\n                        await main(statement.body, env, path);\n                        i++;\n                    }\n                    else {\n                        clearInterval(interval);\n                    }\n                    i++;\n                }, 1000 / 60);\n                asyncWhileLoops.push(interval);\n                break;\n            }\n            case \"while\": {\n                const whileEnv = env.extend();\n                if (statement.else && (await mainExp(statement.cond, whileEnv, path)) === false) {\n                    await main(statement.else, whileEnv, path);\n                }\n                else\n                    while ((await mainExp(statement.cond, whileEnv, path)) !== false) {\n                        await main(statement.body, whileEnv, path);\n                    }\n                return null;\n            }\n            case \"for\":\n                const forEnv = env.extend();\n                await mainExp(statement.init, forEnv, path);\n                while ((await mainExp(statement.check, forEnv, path)) !== false) {\n                    await main(statement.body, forEnv, path);\n                    await mainExp(statement.inc, forEnv, path);\n                }\n                return null;\n            case \"function\": {\n                return make_function(env, statement, path);\n            }\n            case \"class\":\n                return make_class(env, statement, path);\n            case \"record\":\n                statement.body.push({\n                    type: \"func\",\n                    name: \"constructor\",\n                    body: {\n                        type: \"prog\",\n                        prog: statement.vars.map((v) => ({\n                            type: \"statementExpr\",\n                            expr: {\n                                type: \"binary\",\n                                operator: \"=\",\n                                left: {\n                                    type: \"binary\",\n                                    operator: \".\",\n                                    left: {\n                                        type: \"var\",\n                                        value: \"this\"\n                                    },\n                                    right: {\n                                        type: \"var\",\n                                        value: v.name\n                                    }\n                                },\n                                right: {\n                                    type: \"var\",\n                                    value: v.name\n                                }\n                            }\n                        }))\n                    },\n                    vars: statement.vars,\n                    static: false\n                });\n                return make_class(env, {\n                    type: \"class\",\n                    body: statement.body,\n                    extendsName: null,\n                    name: statement.name\n                }, path);\n            case \"import\":\n                await _import(statement, env, path);\n                return null;\n            case \"export\":\n                if (!env.parent)\n                    throwGood(new TypeError(\"No parent env\"));\n                await main(statement, env.parent ?? env, path);\n                return null;\n            default:\n                throwGood(new Error(`I don't know how to main an expression of type \"${statement.type}\"`), pid);\n        }\n    }\n    return main(exp, env, _path);\n}\nexports.evaluate = evaluate;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/eval/evaluate.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/bin/index.js":
/*!*********************************************!*\
  !*** ./node_modules/prgm-lang/bin/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toPRGM_String = void 0;\n__exportStar(__webpack_require__(/*! ./DefaultEnv */ \"./node_modules/prgm-lang/bin/DefaultEnv.js\"), exports);\n__exportStar(__webpack_require__(/*! ./InputStream */ \"./node_modules/prgm-lang/bin/InputStream.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TokenStream */ \"./node_modules/prgm-lang/bin/TokenStream.js\"), exports);\n__exportStar(__webpack_require__(/*! ./eval/Environment */ \"./node_modules/prgm-lang/bin/eval/Environment.js\"), exports);\n__exportStar(__webpack_require__(/*! ./eval/evaluate */ \"./node_modules/prgm-lang/bin/eval/evaluate.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parse */ \"./node_modules/prgm-lang/bin/parse.js\"), exports);\nasync function toPRGM_String(str, env) {\n    return await env.get(\"String\")(str.split(\"\"));\n}\nexports.toPRGM_String = toPRGM_String;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/index.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/bin/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/prgm-lang/bin/parse.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = exports.convertToStatement = exports.ClassUtils = void 0;\nconst InputStream_1 = __webpack_require__(/*! ./InputStream */ \"./node_modules/prgm-lang/bin/InputStream.js\");\nconst TokenStream_1 = __webpack_require__(/*! ./TokenStream */ \"./node_modules/prgm-lang/bin/TokenStream.js\");\nconst FALSE = { type: \"bool\", value: false };\nvar ClassUtils;\n(function (ClassUtils) {\n    function constructorIndex(obj) {\n        for (let i = 0; i < obj.body.length; i++) {\n            const element = obj.body[i];\n            if (element.type == \"func\" && element.name == \"constructor\")\n                return i;\n        }\n        return -1;\n    }\n    ClassUtils.constructorIndex = constructorIndex;\n})(ClassUtils || (exports.ClassUtils = ClassUtils = {}));\nfunction convertToStatement(expr) {\n    return { type: \"statementExpr\", expr };\n}\nexports.convertToStatement = convertToStatement;\nfunction array_forEach_rtn(array, cb) {\n    for (let i = 0; i < array.length; i++) {\n        const element = array[i];\n        const res = cb(element, i, array);\n        if (res)\n            return res;\n    }\n    return undefined;\n}\nfunction parse(str, onError = (err) => { }, testingFlag = false) {\n    const input = new TokenStream_1.TokenStream(new InputStream_1.InputStream(str, onError));\n    let customExpr = new Map();\n    let customStmt = new Map();\n    if (testingFlag) {\n        input.croak = (msg) => { };\n    }\n    const UNARY_OPS = [\"!\", \"-\"];\n    const PRECEDENCE = {\n        \"=\": 1,\n        \"+=\": 1,\n        \"-=\": 1,\n        \"/=\": 1,\n        \"*=\": 1,\n        \"%=\": 1,\n        \"||\": 2,\n        \"&&\": 3,\n        \"<\": 7,\n        \">\": 7,\n        \"<=\": 7,\n        \">=\": 7,\n        \"==\": 7,\n        \"!=\": 7,\n        \"+\": 10,\n        \"-\": 10,\n        \"*\": 20,\n        \"/\": 20,\n        \"%\": 20,\n        \".\": 21\n    };\n    let res = parse_topLevel();\n    return res;\n    function is_punc(ch) {\n        var tok = input.peek();\n        return tok && TokenStream_1.TokenTypeChecks.check(\"punc\", tok) && (!ch || tok.value == ch) && tok;\n    }\n    function is_kw(kw) {\n        var tok = input.peek();\n        return tok && TokenStream_1.TokenTypeChecks.check(\"kw\", tok) && (!kw || tok.value == kw) && tok;\n    }\n    function is_op(op) {\n        var tok = input.peek();\n        return tok && TokenStream_1.TokenTypeChecks.check(\"op\", tok) && (!op || tok.value == op) && tok;\n    }\n    function skip_punc(ch) {\n        if (is_punc(ch))\n            input.next();\n        else\n            input.croak(`Expecting punctuation: \"${ch}\"`);\n    }\n    function skip_kw(kw) {\n        if (is_kw(kw))\n            input.next();\n        else\n            input.croak(`Expecting keyword: \"${kw}\"`);\n    }\n    function skip_op(op) {\n        if (is_op(op))\n            input.next();\n        else\n            input.croak(`Expecting operator: \"${op}\"`);\n    }\n    function unexpected() {\n        return input.croak(`Unexpected token: ${JSON.stringify(input.peek())}`);\n    }\n    function maybe_binary(left, my_prec) {\n        var tok = is_op();\n        if (tok) {\n            var his_prec = PRECEDENCE[tok.value];\n            if (his_prec > my_prec) {\n                input.next();\n                return maybe_binary({\n                    type: \"binary\",\n                    operator: tok.value,\n                    left: left,\n                    right: maybe_binary(parse_atom(), his_prec)\n                }, my_prec);\n            }\n        }\n        return left;\n    }\n    function maybe_access(left, my_prec = 0) {\n        var tok = is_op(\".\");\n        if (tok) {\n            var his_prec = PRECEDENCE[tok.value];\n            if (his_prec > my_prec) {\n                input.next();\n                return maybe_access({\n                    type: \"binary\",\n                    operator: tok.value,\n                    left,\n                    right: maybe_access(parse_atom_withoutCall(), his_prec)\n                }, my_prec);\n            }\n        }\n        return left;\n    }\n    function delimited(start, stop, separator, parser) {\n        var a = [], first = true;\n        skip_punc(start);\n        while (!input.eof()) {\n            if (is_punc(stop))\n                break;\n            if (first)\n                first = false;\n            else\n                skip_punc(separator);\n            if (is_punc(stop))\n                break;\n            a.push(parser());\n        }\n        skip_punc(stop);\n        return a;\n    }\n    function parse_call(func) {\n        return {\n            type: \"call\",\n            func,\n            args: delimited(\"(\", \")\", \",\", parse_expression)\n        };\n    }\n    function parse_arrayAccess(val) {\n        skip_punc(\"[\");\n        let getter = parse_expression();\n        skip_punc(\"]\");\n        return {\n            type: \"binary\",\n            left: val,\n            operator: \"[]\",\n            right: getter\n        };\n    }\n    function parse_varname() {\n        var name = input.next();\n        if (!TokenStream_1.TokenTypeChecks.check(\"var\", name)) {\n            input.croak(\"Expecting variable name\");\n            return \"\";\n        }\n        return name.value;\n    }\n    function parse_if() {\n        skip_kw(\"if\");\n        var cond = parse_expression();\n        if (!is_punc(\"{\"))\n            skip_kw(\"then\");\n        var then = parse_statement();\n        var ret = {\n            type: \"if\",\n            cond,\n            then\n        };\n        if (is_punc(\";\"))\n            input.next();\n        if (is_kw(\"else\")) {\n            input.next();\n            ret.else = parse_statement();\n        }\n        return ret;\n    }\n    function parse_do() {\n        skip_kw(\"do\");\n        const body = parse_statement();\n        skip_kw(\"while\");\n        const cond = parse_expression();\n        skip_punc(\";\");\n        return {\n            type: \"do\",\n            body,\n            cond\n        };\n    }\n    function parse_while() {\n        skip_kw(\"while\");\n        let cond = parse_expression();\n        if (!is_punc(\"{\"))\n            skip_kw(\"then\");\n        let body = parse_statement();\n        let ret = {\n            type: \"while\",\n            cond,\n            body\n        };\n        if (is_kw(\"else\")) {\n            input.next();\n            ret.else = parse_statement();\n        }\n        return ret;\n    }\n    function parse_for() {\n        skip_kw(\"for\");\n        skip_punc(\"(\");\n        let init = parse_expression();\n        skip_punc(\";\");\n        let check = parse_expression();\n        skip_punc(\";\");\n        let inc = parse_expression();\n        skip_punc(\")\");\n        let body = parse_statement();\n        return {\n            type: \"for\",\n            init,\n            check,\n            inc,\n            body\n        };\n    }\n    function parse__while() {\n        skip_kw(\"_while\");\n        let cond = parse_expression();\n        if (!is_punc(\"{\"))\n            skip_kw(\"then\");\n        let body = parse_statement();\n        let ret = {\n            type: \"_while\",\n            cond,\n            body\n        };\n        if (is_kw(\"else\")) {\n            input.next();\n            ret.else = parse_statement();\n        }\n        return ret;\n    }\n    function parse_export() {\n        skip_kw(\"export\");\n        return {\n            type: \"export\",\n            value: parse_statement()\n        };\n    }\n    function parse_import() {\n        skip_kw(\"import\");\n        let value = null;\n        let tok = input.next();\n        if (tok && TokenStream_1.TokenTypeChecks.check(\"str\", tok)) {\n            skip_punc(\";\");\n            return {\n                type: \"import\",\n                value: tok\n            };\n        }\n        else\n            input.croak(`Expecting string, but got \"${tok?.type}\"`);\n        return { type: \"import\", value: { type: \"str\", value: \"\" } };\n    }\n    function parse_argument() {\n        let rtn = {\n            name: parse_varname(),\n            default: null\n        };\n        if (is_op(\"=\")) {\n            input.next();\n            rtn.default = parse_expression();\n        }\n        return rtn;\n    }\n    function parse_arguments() {\n        return delimited(\"(\", \")\", \",\", parse_argument);\n    }\n    function parse_function() {\n        skip_kw(\"function\");\n        let name = parse_varname();\n        if (!name) {\n            return convertToStatement(parse_functionExpr());\n        }\n        let ret = {\n            type: \"function\",\n            vars: parse_arguments(),\n            name,\n            body: parse_statement()\n        };\n        if (name)\n            ret.name = name;\n        return ret;\n    }\n    function parse_functionExpr() {\n        skip_kw(\"function\");\n        let ret = {\n            type: \"functionExpr\",\n            vars: parse_arguments(),\n            body: parse_statement(false)\n        };\n        return ret;\n    }\n    function parse_object() {\n        skip_kw(\"object\");\n        function parseName() {\n            let tok = input.peek();\n            if (tok && TokenStream_1.TokenTypeChecks.check(\"str\", tok))\n                return tok.value;\n            else\n                return parse_varname();\n        }\n        const properties = delimited(\"{\", \"}\", \",\", () => {\n            let name = parseName();\n            skip_punc(\":\");\n            let data = parse_expression();\n            return {\n                name,\n                data\n            };\n        });\n        let data = {};\n        for (const { name, data: _data } of properties) {\n            data[name] = _data;\n        }\n        return {\n            type: \"object\",\n            data\n        };\n    }\n    function parse_class() {\n        skip_kw(\"class\");\n        let res = {\n            type: \"class\",\n            body: [],\n            name: parse_varname(),\n            extendsName: is_kw(\"extends\") ? (skip_kw(\"extends\"), parse_varname()) : null\n        };\n        skip_punc(\"{\");\n        while (!input.eof()) {\n            if (is_punc(\"}\"))\n                break;\n            if (is_kw(\"operator\")) {\n                input.next();\n                let op = \"\";\n                if (is_op()) {\n                    op = input.next().value.toString();\n                }\n                else if (is_punc(\"[\")) {\n                    input.next();\n                    skip_punc(\"]\");\n                    op = \"[]\";\n                }\n                else {\n                    op = parse_varname();\n                }\n                let vars = parse_arguments();\n                let body = parse_prog();\n                if (!body) {\n                    body = convertToStatement(parse_expression());\n                }\n                res.body.push({\n                    type: \"operator\",\n                    op,\n                    value: {\n                        type: \"function\",\n                        body,\n                        vars,\n                        name: \"\"\n                    }\n                });\n            }\n            else if (is_kw(\"constructor\")) {\n                input.next();\n                res.body.push({\n                    type: \"func\",\n                    name: \"constructor\",\n                    vars: parse_arguments(),\n                    body: (() => {\n                        let res = parse_prog();\n                        if (!res)\n                            res = convertToStatement(parse_expression());\n                        return res;\n                    })(),\n                    static: false\n                });\n            }\n            else {\n                let isStatic = false;\n                if (is_kw(\"static\")) {\n                    input.next();\n                    isStatic = true;\n                }\n                let name = parse_varname();\n                let vars = is_punc(\"(\") ? parse_arguments() : null;\n                if (vars) {\n                    let body = parse_prog();\n                    if (!body)\n                        body = convertToStatement(parse_expression());\n                    res.body.push({\n                        type: \"func\",\n                        body,\n                        name,\n                        vars,\n                        static: isStatic\n                    });\n                }\n                else {\n                    skip_op(\"=\");\n                    let value = parse_expression();\n                    res.body.push({\n                        type: \"prop\",\n                        name,\n                        value,\n                        static: isStatic\n                    });\n                    skip_punc(\";\");\n                }\n            }\n        }\n        skip_punc(\"}\");\n        return res;\n    }\n    function parse_record() {\n        skip_kw(\"record\");\n        let res = {\n            type: \"record\",\n            name: parse_varname(),\n            body: [],\n            vars: parse_arguments()\n        };\n        skip_punc(\"{\");\n        while (!input.eof()) {\n            if (is_punc(\"}\"))\n                break;\n            if (is_kw(\"operator\")) {\n                input.next();\n                let op = \"\";\n                if (is_op()) {\n                    op = input.next().value.toString();\n                }\n                else if (is_punc(\"[\")) {\n                    input.next();\n                    skip_punc(\"]\");\n                    op = \"[]\";\n                }\n                else {\n                    op = parse_varname();\n                }\n                let vars = parse_arguments();\n                let body = parse_prog();\n                if (!body) {\n                    body = convertToStatement(parse_expression());\n                }\n                res.body.push({\n                    type: \"operator\",\n                    op,\n                    value: {\n                        type: \"function\",\n                        body,\n                        vars,\n                        name: \"\"\n                    }\n                });\n            }\n            else {\n                let isStatic = false;\n                if (is_kw(\"static\")) {\n                    input.next();\n                    isStatic = true;\n                }\n                let name = parse_varname();\n                let vars = is_punc(\"(\") ? parse_arguments() : null;\n                if (vars) {\n                    let body = parse_prog();\n                    if (!body)\n                        body = convertToStatement(parse_expression());\n                    res.body.push({\n                        type: \"func\",\n                        body,\n                        name,\n                        vars,\n                        static: isStatic\n                    });\n                }\n                else {\n                    skip_op(\"=\");\n                    let value = parse_expression();\n                    res.body.push({\n                        type: \"prop\",\n                        name,\n                        value,\n                        static: isStatic\n                    });\n                    skip_punc(\";\");\n                }\n            }\n        }\n        skip_punc(\"}\");\n        return res;\n    }\n    function parse_bool() {\n        return {\n            type: \"bool\",\n            value: input.next().value == \"true\"\n        };\n    }\n    function parse_null() {\n        skip_kw(\"null\");\n        return {\n            type: \"null\"\n        };\n    }\n    function maybe_call(expr) {\n        const res = expr();\n        return is_punc(\"(\") ? parse_call(res) : res;\n    }\n    function maybe_arrayAccess(expr) {\n        let res = expr();\n        if (!res)\n            res = { type: \"null\" };\n        return is_punc(\"[\") ? parse_arrayAccess(res) : res;\n    }\n    function parse_atom() {\n        return maybe_call(() => maybe_arrayAccess(() => parse_atom_withoutCall()));\n    }\n    function parse_atom_withoutCall() {\n        let left = maybe_arrayAccess(() => {\n            if (is_punc(\"(\")) {\n                input.next();\n                var exp = parse_expression();\n                skip_punc(\")\");\n                return exp;\n            }\n            let op = array_forEach_rtn(UNARY_OPS, (element) => is_op(element));\n            if (op) {\n                input.next();\n                return {\n                    type: \"unary\",\n                    operator: op.value,\n                    body: parse_atom()\n                };\n            }\n            if (is_kw(\"true\") || is_kw(\"false\"))\n                return parse_bool();\n            if (is_kw(\"null\"))\n                return parse_null();\n            if (is_kw(\"object\"))\n                return parse_object();\n            if (is_kw(\"function\")) {\n                return parse_functionExpr();\n            }\n            var tok = input.next();\n            if (tok &&\n                (TokenStream_1.TokenTypeChecks.check(\"var\", tok) || TokenStream_1.TokenTypeChecks.check(\"num\", tok) || TokenStream_1.TokenTypeChecks.check(\"str\", tok) || TokenStream_1.TokenTypeChecks.check(\"char\", tok)))\n                return tok;\n            unexpected();\n            return;\n        });\n        if (!left)\n            left = { type: \"null\" };\n        return maybe_access(left);\n    }\n    function parse_topLevel() {\n        var prog = [];\n        while (!input.eof()) {\n            let expr = parse_statement();\n            prog.push(expr);\n        }\n        return { type: \"prog\", prog };\n    }\n    function parse_prog() {\n        if (!is_punc(\"{\"))\n            return;\n        skip_punc(\"{\");\n        var prog = [];\n        while (!input.eof() && !is_punc(\"}\")) {\n            let statement = parse_statement();\n            prog.push(statement);\n        }\n        skip_punc(\"}\");\n        return { type: \"prog\", prog: prog };\n    }\n    function parse_expression() {\n        return maybe_call(() => {\n            return maybe_binary(parse_atom(), 0);\n        });\n    }\n    function parse_statement(requireSemiColon = true) {\n        let res;\n        if (is_punc(\"{\")) {\n            let _res = parse_prog();\n            if (_res)\n                res = _res;\n        }\n        else if (is_kw(\"if\"))\n            res = parse_if();\n        else if (is_kw(\"do\"))\n            res = parse_do();\n        else if (is_kw(\"_while\"))\n            res = parse__while();\n        else if (is_kw(\"while\"))\n            res = parse_while();\n        else if (is_kw(\"for\"))\n            res = parse_for();\n        else if (is_kw(\"function\"))\n            res = parse_function();\n        else if (is_kw(\"class\"))\n            res = parse_class();\n        else if (is_kw(\"record\"))\n            res = parse_record();\n        else if (is_kw(\"import\"))\n            res = parse_import();\n        else if (is_kw(\"export\"))\n            res = parse_export();\n        else if (is_kw(\"syntax\")) {\n            parse_syntax();\n            res = { type: \"statementExpr\", expr: { type: \"null\" } };\n        }\n        if (typeof res == \"undefined\") {\n            let expr = parse_expression();\n            if (expr) {\n                if (requireSemiColon)\n                    skip_punc(\";\");\n                res = { type: \"statementExpr\", expr };\n            }\n        }\n        if (res) {\n            if (is_punc(\";\")) {\n                unexpected();\n                input.next();\n            }\n            return res;\n        }\n        unexpected();\n        return { type: \"statementExpr\", expr: { type: \"null\" } };\n    }\n    function parse_syntax() {\n        skip_kw(\"syntax\");\n        let tokens = [];\n        let parenCount = 1;\n        let type = \"expr\";\n        if (is_punc(\"(\")) {\n            type = \"expr\";\n            while (!input.eof() && parenCount > 0) {\n                let tok = input.next();\n                if (!tok)\n                    break;\n                if (tok.type == \"punc\") {\n                    if (tok.value == \"(\")\n                        parenCount++;\n                    else if (tok.value == \")\")\n                        parenCount--;\n                }\n                tokens.push(tok);\n            }\n        }\n        else if (is_punc(\"{\")) {\n            type = \"stmt\";\n            while (!input.eof() && parenCount > 0) {\n                let tok = input.next();\n                if (!tok)\n                    break;\n                if (tok.type == \"punc\") {\n                    if (tok.value == \"{\")\n                        parenCount++;\n                    else if (tok.value == \"}\")\n                        parenCount--;\n                }\n                tokens.push(tok);\n            }\n        }\n    }\n}\nexports.parse = parse;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/parse.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/bin/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/prgm-lang/bin/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useUtils = void 0;\nArray.prototype.asyncMap = async function asyncMap(cb) {\n    let arr = [];\n    for (let index = 0; index < this.length; index++) {\n        const value = this[index];\n        arr.push(await cb(value, index, this));\n    }\n    return arr;\n};\nfunction useUtils() { }\nexports.useUtils = useUtils;\n\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/bin/utils.js?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary sync recursive ^\\.\\/.*$":
/*!***************************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/ sync ^\.\/.*$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./Array.prgm\": \"./node_modules/prgm-lang/standardLibrary/Array.prgm\",\n\t\"./Button.prgm\": \"./node_modules/prgm-lang/standardLibrary/Button.prgm\",\n\t\"./Map.prgm\": \"./node_modules/prgm-lang/standardLibrary/Map.prgm\",\n\t\"./Point.prgm\": \"./node_modules/prgm-lang/standardLibrary/Point.prgm\",\n\t\"./Rect.prgm\": \"./node_modules/prgm-lang/standardLibrary/Rect.prgm\",\n\t\"./String.prgm\": \"./node_modules/prgm-lang/standardLibrary/String.prgm\",\n\t\"./Vec2.prgm\": \"./node_modules/prgm-lang/standardLibrary/Vec2.prgm\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/prgm-lang/standardLibrary sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/_sync_^\\.\\/.*$?");

/***/ }),

/***/ "./src/AppUtils.ts":
/*!*************************!*\
  !*** ./src/AppUtils.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAppSourceCode = exports.stopApp = exports.openApplication = exports.addApp = exports.defineApplication = exports.Listeners = void 0;\nconst prgm_lang_1 = __webpack_require__(/*! prgm-lang */ \"./node_modules/prgm-lang/bin/index.js\");\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst Storage_1 = __webpack_require__(/*! ./Storage */ \"./src/Storage.ts\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./src/Window.ts\");\nvar Listeners;\n(function (Listeners) {\n    function listen(type, listener, window) {\n        switch (type) {\n            case \"keydown\":\n            case \"keyup\": {\n                let listenerFunction = (e) => {\n                    if (window.hasFocus) {\n                        listener(e);\n                    }\n                };\n                addEventListener(type, listenerFunction);\n                return [type, listenerFunction];\n            }\n            case \"mousedown\":\n            case \"mouseup\":\n            case \"mousemove\":\n            case \"click\": {\n                let listenerFunction = mouseListenerFunction(listener, window);\n                addEventListener(type, listenerFunction);\n                return [type, listenerFunction];\n            }\n            default:\n                throw new TypeError(`Unknown listener type: ${type}`);\n        }\n    }\n    Listeners.listen = listen;\n    function mouseListenerFunction(listener, window) {\n        let listenerFunction = (e) => {\n            let res = { x: e.clientX - _1.canvas.offsetLeft, y: e.clientY - _1.canvas.offsetTop };\n            res.x -= window.x;\n            res.y -= window.y;\n            if (window.hasFocus && res.y >= 0) {\n                listener(res);\n            }\n        };\n        return listenerFunction;\n    }\n})(Listeners || (exports.Listeners = Listeners = {}));\nlet applications = {};\nconst defaultAppOptions = {\n    useConsole: true\n};\nfunction mergeValues(required, partial) {\n    let res = {};\n    if (typeof partial == \"undefined\") {\n        res = required;\n    }\n    else\n        for (const key in required) {\n            const element = partial[key];\n            if (typeof element == \"undefined\" || element == null) {\n                res[key] = required[key];\n            }\n            else {\n                res[key] = element;\n            }\n        }\n    return res;\n}\nfunction defineApplication(name, data, options) {\n    if (/^[a-z\\d/]+$/gi.test(name)) {\n        let newOptions = mergeValues(defaultAppOptions, options);\n        applications[name] = { data, options: newOptions };\n    }\n}\nexports.defineApplication = defineApplication;\nlet processes = [];\nlet windows = [];\nlet listeners = [];\nasync function addApp(name) {\n    const apps = Storage_1.storage.getItem(\"apps\");\n    if (!apps.includes(name)) {\n        apps.push(name);\n    }\n    Storage_1.storage.setItem(\"apps\", apps);\n}\nexports.addApp = addApp;\nasync function openApplication(name) {\n    return new Promise(async (resolve) => {\n        if (name in applications) {\n            const apps = Storage_1.storage.getItem(\"apps\");\n            if (!apps.includes(name)) {\n                apps.push(name);\n            }\n            Storage_1.storage.setItem(\"apps\", apps);\n            let pid = 0;\n            processes.forEach((process) => {\n                if (process.pid > pid)\n                    pid = process.pid;\n            });\n            pid++;\n            resolve(pid);\n            let env = (0, prgm_lang_1.defaultEnv)();\n            processes[pid] = {\n                env,\n                pid\n            };\n            env.def(\"listen\", async (type, listener, window) => {\n                let str = await type.toString();\n                listeners.push({ pid, data: Listeners.listen(str, listener, window) });\n            });\n            env.def(\"Window\", async (title, width, height, x, y) => {\n                let window = new Window_1.Window(await title.toString(), x ?? Window_1.Window.WINDOWPOS_CENTERED_X, y ?? Window_1.Window.WINDOWPOS_CENTERED_Y, width, height, pid);\n                windows.push({ pid, data: window });\n                return window;\n            });\n            env.def(\"storage\", {\n                async getItem(_name) {\n                    let str = await _name.toString();\n                    let res = Storage_1.storage.getItem(`app::${name}::${str}`);\n                    if (res === undefined)\n                        res = null;\n                    return res;\n                },\n                async setItem(_name, value) {\n                    let str = await _name.toString();\n                    let _value;\n                    if (value.__isString__ === true)\n                        _value = await value.toString();\n                    else\n                        _value = value;\n                    Storage_1.storage.setItem(`app::${name}::${str}`, value);\n                    return value;\n                }\n            });\n            async function println(...data) {\n                let res = [];\n                for (const v of data) {\n                    res.push(typeof v == \"object\" && v && v.__isString__ === true ? await v.toString() : v);\n                }\n                console.log(`${name}>`, ...res);\n            }\n            env.def(\"println\", println);\n            env.def(\"console\", {\n                log: println\n            });\n            env.def(\"fetch\", async (_url) => {\n                let url = await _url.toString();\n                return await (0, prgm_lang_1.toPRGM_String)(await (await fetch(url)).text(), env);\n            });\n            let exitCode = (0, prgm_lang_1.evaluate)((0, prgm_lang_1.parse)(applications[name].data), env, pid, name.split(\"/\").slice(0, -1).join(\"/\"), (code) => {\n                _stopApp(pid);\n            });\n            return exitCode;\n        }\n        else {\n            defineApplication(name, await getAppSourceCode(name));\n            await openApplication(name);\n            return;\n            console.error(`Application \"${name}\" not found.`);\n        }\n    });\n}\nexports.openApplication = openApplication;\nasync function stopApp(pid) {\n    if (processes[pid]) {\n        processes[pid].env.get(\"exit\")();\n    }\n    await _stopApp(pid);\n}\nexports.stopApp = stopApp;\nasync function _stopApp(pid) {\n    for (let i = 0; i < windows.length; i++) {\n        const window = windows[i];\n        if (window.pid === pid)\n            window.data.closeAfterStop();\n    }\n    windows = windows.filter((val) => val.pid === pid);\n    for (let i = 0; i < listeners.length; i++) {\n        const element = listeners[i];\n        if (element.pid === pid)\n            removeEventListener(element.data[0], element.data[1]);\n    }\n    listeners = listeners.filter((val) => val.pid === pid);\n}\nasync function getAppSourceCode(name) {\n    return await (await fetch(`${name}.prgm`)).text();\n}\nexports.getAppSourceCode = getAppSourceCode;\n\n\n//# sourceURL=webpack://os2/./src/AppUtils.ts?");

/***/ }),

/***/ "./src/Button.ts":
/*!***********************!*\
  !*** ./src/Button.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Button = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./src/Window.ts\");\nclass Button {\n    static buttons = [];\n    x;\n    y;\n    width;\n    height;\n    listeners = [];\n    constructor(x, y, width, height, draw) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.draw = draw ?? this.draw;\n        Button.buttons.push(this);\n    }\n    destroy() {\n        if (Button.buttons.includes(this))\n            Button.buttons.splice(Button.buttons.indexOf(this), 1);\n    }\n    listen(type, listener) {\n        let _val = {\n            call: listener,\n            type\n        };\n        this.listeners.push(_val);\n    }\n    click() {\n        for (let i = 0; i < this.listeners.length; i++) {\n            const element = this.listeners[i];\n            if (element.type == \"click\") {\n                element.call({ x: _1.mouse.x, y: _1.mouse.y });\n            }\n        }\n    }\n    static clickAll() {\n        Window_1.Window.clickAll();\n        for (let i = 0; i < this.buttons.length; i++) {\n            const button = this.buttons[i];\n            if (_1.mouse.x > button.x &&\n                _1.mouse.x < button.x + button.width &&\n                _1.mouse.y > button.y &&\n                _1.mouse.y < button.y + button.height) {\n                button.click();\n            }\n        }\n    }\n    static unClickAll() {\n        Window_1.Window.unClickAll();\n    }\n    draw() {\n        _1.c.fillStyle = \"black\";\n        _1.c.fillRect(this.x, this.y, this.width, this.height);\n    }\n    static drawAll(buttons) {\n        for (const btn of buttons) {\n            btn.draw();\n        }\n    }\n}\nexports.Button = Button;\n\n\n//# sourceURL=webpack://os2/./src/Button.ts?");

/***/ }),

/***/ "./src/Graphics/Graphics.ts":
/*!**********************************!*\
  !*** ./src/Graphics/Graphics.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Graphics = void 0;\nconst prgm_lang_1 = __webpack_require__(/*! prgm-lang */ \"./node_modules/prgm-lang/bin/index.js\");\nclass Graphics {\n    target;\n    constructor(target) {\n        this.target = target;\n    }\n    async fillRect(x, y, w, h) {\n        this.target.c_drawBuffer.fillStyle = await this.fillStyle.toString();\n        this.target.c_drawBuffer.fillRect(x, y, w, h);\n    }\n    async fillText(text, x, y) {\n        let str = await text.toString();\n        this.target.c_drawBuffer.fillStyle = await this.fillStyle.toString();\n        this.target.c_drawBuffer.font = await this.font.toString();\n        this.target.c_drawBuffer.fillText(str, x, y);\n    }\n    async textWidth(text) {\n        let str = await text.toString();\n        return this.target.c_drawBuffer.measureText(str).width;\n    }\n    clearRect(x, y, w, h) {\n        this.target.c_drawBuffer.clearRect(x, y, w, h);\n    }\n    clearScreen() {\n        this.fillRect(0, 0, this.target.drawBuffer.width, this.target.drawBuffer.height);\n    }\n    fillStyle = new prgm_lang_1.PRGM_String();\n    font = new prgm_lang_1.PRGM_String();\n}\nexports.Graphics = Graphics;\n\n\n//# sourceURL=webpack://os2/./src/Graphics/Graphics.ts?");

/***/ }),

/***/ "./src/Storage.ts":
/*!************************!*\
  !*** ./src/Storage.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.storage = exports.Storage = exports.expandObjectRef = exports.expandObject = void 0;\nfunction expandObject(obj, key) {\n    if (!key.includes(\"::\"))\n        return obj[key];\n    else {\n        let path = key.split(\"::\");\n        let name = path.shift();\n        return expandObject((obj[name] = obj[name] ?? {}), path.join(\"::\"));\n    }\n}\nexports.expandObject = expandObject;\nfunction expandObjectRef(obj, key) {\n    if (!key.includes(\"::\"))\n        return [obj, key];\n    else {\n        let path = key.split(\"::\");\n        let name = path.shift();\n        return expandObjectRef((obj[name] = obj[name] ?? {}), path.join(\"::\"));\n    }\n}\nexports.expandObjectRef = expandObjectRef;\nclass Storage {\n    storageObj;\n    constructor(storageObj) {\n        this.storageObj = storageObj;\n    }\n    getItem(name) {\n        let path = name.split(\"::\");\n        let lsName = path.shift();\n        if (!this.storageObj.getItem(lsName))\n            return null;\n        let data = JSON.parse(this.storageObj.getItem(lsName) || \"{}\");\n        if (path.length > 0)\n            return expandObject(data, path.join(\"::\"));\n        else\n            return data;\n    }\n    setItem(name, value) {\n        let path = name.split(\"::\");\n        let lsName = path.shift();\n        let data = JSON.parse(this.storageObj.getItem(lsName) || \"{}\");\n        if (path.length > 0) {\n            let [obj, key] = expandObjectRef(data, path.join(\"::\"));\n            obj[key] = value;\n            this.storageObj.setItem(lsName, JSON.stringify(data));\n            return obj[key];\n        }\n        else {\n            this.storageObj.setItem(lsName, JSON.stringify(value));\n        }\n    }\n}\nexports.Storage = Storage;\nexports.storage = new Storage(localStorage);\n\n\n//# sourceURL=webpack://os2/./src/Storage.ts?");

/***/ }),

/***/ "./src/Window.ts":
/*!***********************!*\
  !*** ./src/Window.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Window = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst AppUtils_1 = __webpack_require__(/*! ./AppUtils */ \"./src/AppUtils.ts\");\nconst Button_1 = __webpack_require__(/*! ./Button */ \"./src/Button.ts\");\nconst Graphics_1 = __webpack_require__(/*! ./Graphics/Graphics */ \"./src/Graphics/Graphics.ts\");\nconst taskbar_1 = __webpack_require__(/*! ./taskbar */ \"./src/taskbar.ts\");\nconst defaultWindowOptions = {};\nclass Window {\n    title;\n    x;\n    y;\n    width;\n    height;\n    oldX;\n    oldY;\n    oldW;\n    oldH;\n    hasFocus = false;\n    pid;\n    xBtn;\n    isOpen = true;\n    options;\n    drawBuffer;\n    c_drawBuffer;\n    constructor(title, x, y, width, height, pid, options) {\n        this.options = Object.assign({}, defaultWindowOptions, options);\n        this.pid = pid;\n        this.drawBuffer = document.createElement(\"canvas\");\n        this.c_drawBuffer = this.drawBuffer.getContext(\"2d\");\n        this.drawBuffer.width = width;\n        this.drawBuffer.height = height;\n        y += Window.titleHeight;\n        this.title = title;\n        this.x = x == Window.WINDOWPOS_CENTERED_X ? x - width / 2 : x;\n        this.y = y == Window.WINDOWPOS_CENTERED_Y + Window.titleHeight ? y - height / 2 - taskbar_1.Taskbar.height : y;\n        for (let i = 0; i < Window.windows.length; i++) {\n            const element = Window.windows[i];\n            if (x == element.x && y == element.y) {\n                x += 100;\n                y += 100;\n                break;\n            }\n        }\n        this.width = width;\n        this.height = height;\n        this.oldX = this.x;\n        this.oldY = this.y;\n        this.oldW = this.width;\n        this.oldH = this.height;\n        this.xBtn = new Button_1.Button(this.x + this.width - 25, this.y + 5 - Window.titleHeight, 20, 20, function () {\n            _1.c.drawImage(Window.xBtn, this.x, this.y, this.width, this.height);\n        });\n        this.xBtn.listen(\"click\", this.close.bind(this));\n        Window.windows.push(this);\n    }\n    isLastWindow() {\n        let amount = 0;\n        for (let i = 0; i < Window.windows.length; i++) {\n            const window = Window.windows[i];\n            if (window.pid === this.pid)\n                amount++;\n        }\n        return amount <= 1;\n    }\n    close() {\n        if (this.isOpen) {\n            this.isOpen = false;\n            Window.windows.splice(Window.windows.indexOf(this), 1);\n            this.xBtn.destroy();\n            if (this.isLastWindow())\n                (0, AppUtils_1.stopApp)(this.pid);\n        }\n    }\n    closeAfterStop() {\n        if (this.isOpen) {\n            this.isOpen = false;\n            Window.windows.splice(Window.windows.indexOf(this), 1);\n            this.xBtn.destroy();\n        }\n    }\n    static windows = [];\n    static xBtn;\n    pos1 = 0;\n    pos2 = 0;\n    pos3 = 0;\n    pos4 = 0;\n    static async init() {\n        this.xBtn = await (0, _1.newImage)(\"/x.png\");\n    }\n    static titleHeight = 30;\n    draw() {\n        _1.c.fillStyle = \"white\";\n        _1.c.fillRect(this.x, this.y, this.width, this.height);\n        _1.c.fillStyle = this.hasFocus ? _1.settings.theme.main : _1.settings.theme.lostFocus;\n        _1.c.fillRect(this.x, this.y - Window.titleHeight, this.width, Window.titleHeight);\n        this.xBtn.x = this.x + this.width - 25;\n        this.xBtn.y = this.y + 5 - Window.titleHeight;\n        this.xBtn.draw();\n        _1.c.fillStyle = _1.settings.theme.main == \"black\" ? \"white\" : \"black\";\n        _1.c.font = \"20px Arial\";\n        _1.c.fillText(this.title, this.x + 5, this.y + +_1.c.font.replace(/[^\\d.]/g, \"\") + 2.5 - Window.titleHeight);\n        _1.c.drawImage(this.drawBuffer, this.x, this.y);\n    }\n    titleBarClicked = false;\n    move() {\n        if (this.hasFocus) {\n            if (this.titleBarClicked) {\n                this.pos1 = this.pos3 - _1.mouse.x;\n                this.pos2 = this.pos4 - _1.mouse.y;\n                this.pos3 = _1.mouse.x;\n                this.pos4 = _1.mouse.y;\n                this.y -= this.pos2;\n                this.x -= this.pos1;\n            }\n        }\n    }\n    click() {\n        this.pos3 = _1.mouse.x;\n        this.pos4 = _1.mouse.y;\n        if (_1.mouse.x > this.x && _1.mouse.x < this.x + this.width && _1.mouse.y > this.y + 5 - Window.titleHeight && _1.mouse.y < this.y) {\n            this.titleBarClicked = true;\n            if (this.maximized)\n                this.restore();\n        }\n    }\n    unClick() {\n        this.titleBarClicked = false;\n        if (_1.mouse.y <= 0)\n            this.maximize();\n    }\n    maximized = false;\n    maximize() {\n        this.oldX = this.x;\n        this.oldY = this.y;\n        this.oldW = this.width;\n        this.oldH = this.height;\n        this.x = 0;\n        this.y = 0;\n        this.width = _1.canvas.width;\n        this.height = _1.canvas.height - taskbar_1.Taskbar.height;\n        this.maximized = true;\n    }\n    restore() {\n        this.width = this.oldW;\n        this.height = this.oldH;\n        this.x = _1.mouse.x - this.width / 2;\n        this.maximized = false;\n    }\n    getGraphics() {\n        return new Graphics_1.Graphics(this);\n    }\n    keyListeners = [];\n    keyUpListeners = [];\n    clickListeners = [];\n    rects = [];\n    static drawAll() {\n        this.moveAll();\n        for (let i = this.windows.length - 1; i >= 0; i--) {\n            this.windows[i].draw();\n        }\n    }\n    static noFocusedWindows() {\n        for (const window of this.windows) {\n            if (window.hasFocus)\n                return false;\n        }\n        return true;\n    }\n    static clickAll() {\n        for (let i = 0; i < this.windows.length; i++) {\n            const window = this.windows[i];\n            if (_1.mouse.x > window.x &&\n                _1.mouse.x < window.x + window.width &&\n                _1.mouse.y > window.y - Window.titleHeight &&\n                _1.mouse.y < window.y + window.height &&\n                _1.mouseDown) {\n                if ((this.windows[0] != window && !this.windows[0].hasFocus) || this.windows.length == 1 || this.noFocusedWindows()) {\n                    window.hasFocus = true;\n                    this.windows.splice(this.windows.indexOf(window), 1);\n                    this.windows.unshift(window);\n                }\n                if (this.windows[0] == window && window.hasFocus) {\n                    window.click();\n                }\n            }\n            else {\n                window.hasFocus = false;\n            }\n        }\n    }\n    static unClickAll() {\n        for (let i = 0; i < this.windows.length; i++) {\n            this.windows[i].unClick();\n        }\n    }\n    static moveAll() {\n        for (let i = 0; i < this.windows.length; i++) {\n            this.windows[i].move();\n        }\n    }\n    static WINDOWPOS_CENTERED_X = _1.canvas.width / 2;\n    static WINDOWPOS_CENTERED_Y = _1.canvas.height / 2;\n}\nexports.Window = Window;\n\n\n//# sourceURL=webpack://os2/./src/Window.ts?");

/***/ }),

/***/ "./src/desktop.ts":
/*!************************!*\
  !*** ./src/desktop.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.desktop = exports.Desktop = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nclass Desktop {\n    image;\n    async init() {\n        this.image = await (0, _1.newImage)(\"/wallpaper.jpg\");\n    }\n    draw() {\n        _1.c.drawImage(this.image, 0, 0);\n    }\n}\nexports.Desktop = Desktop;\nexports.desktop = new Desktop();\n\n\n//# sourceURL=webpack://os2/./src/desktop.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.newImage = exports.draw = exports.c = exports.mouseDown = exports.settings = exports.mouse = exports.canvas = void 0;\nexports.canvas = document.querySelector(\"canvas\");\nfunction resize() {\n    exports.canvas.width = innerWidth;\n    exports.canvas.height = innerHeight;\n}\nresize();\nconst Button_1 = __webpack_require__(/*! ./Button */ \"./src/Button.ts\");\nconst Window_1 = __webpack_require__(/*! ./Window */ \"./src/Window.ts\");\nconst desktop_1 = __webpack_require__(/*! ./desktop */ \"./src/desktop.ts\");\nconst taskbar_1 = __webpack_require__(/*! ./taskbar */ \"./src/taskbar.ts\");\naddEventListener(\"resize\", resize);\nexports.mouse = {\n    x: 0,\n    y: 0\n};\nexports.settings = {\n    theme: {\n        main: \"#7eb5c7\",\n        lostFocus: \"lightblue\"\n    }\n};\nexports.mouseDown = false;\nexports.canvas.addEventListener(\"mousemove\", (e) => {\n    exports.mouse.x = e.clientX;\n    exports.mouse.y = e.clientY;\n});\nexports.canvas.addEventListener(\"mousedown\", () => ((exports.mouseDown = true), Button_1.Button.clickAll()));\nexports.canvas.addEventListener(\"mouseup\", () => ((exports.mouseDown = false), Button_1.Button.unClickAll()));\nexports.c = exports.canvas.getContext(\"2d\");\nasync function draw() {\n    desktop_1.desktop.draw();\n    taskbar_1.taskbar.draw();\n    Window_1.Window.drawAll();\n}\nexports.draw = draw;\nasync function main() {\n    await desktop_1.desktop.init();\n    await taskbar_1.taskbar.init();\n    await Window_1.Window.init();\n    setInterval(draw, 1000 / 60);\n}\nasync function newImage(src) {\n    return new Promise((resolve) => {\n        let image = new Image();\n        image.addEventListener(\"load\", () => resolve(image));\n        image.src = src;\n    });\n}\nexports.newImage = newImage;\nmain();\n\n\n//# sourceURL=webpack://os2/./src/index.ts?");

/***/ }),

/***/ "./src/taskbar.ts":
/*!************************!*\
  !*** ./src/taskbar.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.taskbar = exports.Taskbar = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst AppUtils_1 = __webpack_require__(/*! ./AppUtils */ \"./src/AppUtils.ts\");\nconst Button_1 = __webpack_require__(/*! ./Button */ \"./src/Button.ts\");\nconst Storage_1 = __webpack_require__(/*! ./Storage */ \"./src/Storage.ts\");\nclass Taskbar {\n    static height = 40;\n    icons = [];\n    async init() {\n        Storage_1.storage.setItem(\"apps\", Storage_1.storage.getItem(\"apps\") || []);\n        await (0, AppUtils_1.addApp)(\"/prgm/appStore\");\n        let apps = Storage_1.storage.getItem(\"apps\");\n        for (const name of apps) {\n            await this.makeIcon(name);\n        }\n    }\n    async makeIcon(name) {\n        let iconPath = (await (0, AppUtils_1.getAppSourceCode)(name)).split(\"\\n\")[0];\n        if (!iconPath.startsWith(\"##icon=\"))\n            return;\n        else\n            iconPath = iconPath.slice(7);\n        const icon = await (0, _1.newImage)(iconPath);\n        let btn = new Button_1.Button(this.icons.length * Taskbar.height, _1.canvas.height - Taskbar.height, Taskbar.height, Taskbar.height, function () {\n            _1.c.drawImage(icon, this.x, this.y, this.width, this.height);\n        });\n        btn.listen(\"click\", () => {\n            (0, AppUtils_1.openApplication)(name);\n        });\n        this.icons.push(btn);\n    }\n    draw() {\n        _1.c.fillStyle = _1.settings.theme.main;\n        _1.c.fillRect(0, _1.canvas.height - Taskbar.height, _1.canvas.width, Taskbar.height);\n        Button_1.Button.drawAll(this.icons);\n    }\n}\nexports.Taskbar = Taskbar;\nexports.taskbar = new Taskbar();\n\n\n//# sourceURL=webpack://os2/./src/taskbar.ts?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary/Array.prgm":
/*!***********************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/Array.prgm ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"7fd3633ed1a12da8633e.prgm\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/Array.prgm?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary/Button.prgm":
/*!************************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/Button.prgm ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"5087b60757eaad7c47ad.prgm\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/Button.prgm?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary/Map.prgm":
/*!*********************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/Map.prgm ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"7e4fc6deca5c70f326a5.prgm\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/Map.prgm?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary/Point.prgm":
/*!***********************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/Point.prgm ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"1f738ec818d0c4a36e81.prgm\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/Point.prgm?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary/Rect.prgm":
/*!**********************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/Rect.prgm ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"72fc837251740628b41b.prgm\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/Rect.prgm?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary/String.prgm":
/*!************************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/String.prgm ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"61f3a240e1e194c0efe8.prgm\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/String.prgm?");

/***/ }),

/***/ "./node_modules/prgm-lang/standardLibrary/Vec2.prgm":
/*!**********************************************************!*\
  !*** ./node_modules/prgm-lang/standardLibrary/Vec2.prgm ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"4a93a23cede5463743ad.prgm\";\n\n//# sourceURL=webpack://os2/./node_modules/prgm-lang/standardLibrary/Vec2.prgm?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;